\documentclass[11pt]{aghdpl}
% \documentclass[en,11pt]{aghdpl}  % praca w języku angielskim
\renewcommand{\labelitemi}{$\bullet$}

\usepackage[polish]{babel}
%\usepackage[english]{babel}
\usepackage[utf8]{inputenc}

% dodatkowe pakiety
\usepackage{enumerate}
\usepackage{mathtools}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{caption}

\lstloadlanguages{TeX}

\lstset{
captionpos=b,
frame=single,
breaklines=true,
postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}},
literate={ą}{{\k{a}}}1
{ć}{{\'c}}1
{ę}{{\k{e}}}1
{ó}{{\'o}}1
{ń}{{\'n}}1
{ł}{{\l{}}}1
{ś}{{\'s}}1
{ź}{{\'z}}1
{ż}{{\.z}}1
{Ą}{{\k{A}}}1
{Ć}{{\'C}}1
{Ę}{{\k{E}}}1
{Ó}{{\'O}}1
{Ń}{{\'N}}1
{Ł}{{\L{}}}1
{Ś}{{\'S}}1
{Ź}{{\'Z}}1
{Ż}{{\.Z}}1
}

\graphicspath{ {./gfx/} }

%---------------------------------------------------------------------------

\author{Mateusz Kulpa}
\shortauthor{M. Kulpa}

\titlePL{Projekt i~implementacja mobilnego systemu wspomagającego prowadzenie gabinetu lekarskiego w technologii JavaEE oraz Android}
\titleEN{Design and implementation of mobile doctors office management system using JavaEE and Android technologies}

\shorttitlePL{Projekt i~implementacja mobilnego systemu wspomagającego prowadzenie gabinetu lekarskiego w technologii JavaEE oraz Android}
\shorttitleEN{Skrócony tytuł angielski}

\thesistype{Praca dyplomowa magisterska}

\supervisor{dr inż.\ Paweł Skrzyński}

\degreeprogramme{Informatyka}

\date{2014}

\department{Katedra Informatyki Stosowanej}
%\department{Department of Applied Computer Science}

\faculty{Wydział Elektrotechniki, Automatyki,\protect\\[-1mm] Informatyki i Inżynierii Biomedycznej}
%\faculty{Faculty of Electrical Engineering, Automatics, Computer Science and Biomedical Engineering}

\acknowledgements{Serdecznie dziękuję \dots tu ciąg dalszych podziękowań np. dla promotora, żony, sąsiada itp.}


\setlength{\cftsecnumwidth}{10mm}

%---------------------------------------------------------------------------
\long\def\/*#1*/{}
%Cytaty ``''
%obrazki 
\/*
\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth * 4/5]{MVC-MOBILE}
	\caption{Schemat MVC z wyszczególnieniem platformy mobilnej}
	\label{fig:mvc-mobile}
\end{figure}
*/


%TODO Content Negotiation
%TODO ajax, jquery?
%TODO play - formularze z zagnieżdżonymi obiektami oraz listami
%TODO? hibernate, jackson, lazy-load (VisitController.list)
%TODO? paginator w sql injection albo rozdziale o paginacji? jeśli w rozdziale o paginacji to wspomnieć w sql injection że jest tam przykład JPA Criteria API
%TODO wypełnienie danymi
%TODO? brak rozliczeń z NFZ
%TODO apliakacja mobilna a service - cookies, bezpieczeństwo, opisać w implementacji na najwyższym poziomie, propertiesy czy jak to się zwało do ustawien? sesja

\setcounter{secnumdepth}{3}

\begin{document}


\titlepages

\begin{abstract}

Niniejsza praca opisuje etapy implementacji narzędzia wspomagającego pracę gabinetu lekarskiego. Głównym podmiotem pracy nie jest stworzenie kompletnego rozwiązania dla lekarzy zgodnego z~ obowiązującymi normami, a przedstawienie sposobu implementacji systemu składającego się  z~kilku komponentów, z~którego można korzystać przy pomocy przeglądarki internetowej oraz aplikacji dedykowanej na platformę Android. Ze względu na duże zróżnicowanie potrzeb w zależności od dziedziny medycyny zdecydowano się na implementację narzędzia przeznaczonego dla gabinetu dentystycznego. 

W pracy poruszane są kwestie projektowania aplikacji biznesowej pod kątem dostępnych obecnie technologii z~naciskiem na interfejsy poszczególnych warstw. Szczegółowo opisywane są również typowe problemy bezpieczeństwa z~jakimi trzeba się zmagać podczas implementacji poszczególnych modułów takie jak uwierzytelnianie, bezpieczny mechanizm resetu hasła czy ataki Replay oraz SQL Injection.

Pomimo zawężenia problemu do wielkości pozwalającej skupieniu się na szczegółach projektowania i~ implementacji, opisywany system realizuje w podstawowym stopniu potrzeby związane z prowadzeniem przychodni stomatologicznej i~może zostać dlań wykorzystany.

\end{abstract}

\setcounter{tocdepth}{3}
\tableofcontents
\clearpage

%----------------------------------------------------------------------------

\chapter{Wstęp}
\label{cha:wstep}
%TODO problem spójności api
%TODO praca odnosi się do konkretnych frameworków i niektóre rozwiązania są do zastosowania tylko w ich obrębie, ale niektóre zagadnienia mają charakter ogólny
\section{Cele pracy}
\label{sec:cele_pracy}

\section{Zawartość pracy}
\label{sec:zawartosc_pracy}

%----------------------------------------------------------------------------

\chapter{Architektura}
\label{cha:architektura}

\section{Architektura fizyczna}
\label{sec:architektura_fizyczna}

\section{Architektura logiczna}
\label{sec:architektura_logiczna}

%----------------------------------------------------------------------------

\chapter{Projekt}
\label{cha:dobor_technologii_i_narzedzi}

Głównym problemem w~projektowaniu systemu składającego się z~wielu komponentów jest dopasowanie interfejsów do każdego z~nich, co będzie głównym tematem tego rozdziału. Omówione zostaną zadania charakterystyczne dla każdego modułu aplikacji i~sposób integracji pomiędzy nimi.

W~rozdziale tym opisane będą również technologie i~narzędzia użyte do implementacji każdej z~warstw aplikacji. Nie uwzględniono przy tym bibliotek zastosowanych do rozwiązania konkretnych problemów dla danej warstwy, a~jedynie elementy niezbędne do zrozumienia struktury systemu i~sposobu komunikacji pomiędzy poszczególnymi modułami. Projekt realizowany będzie w głównej mierze z~wykorzystaniem technologii Java, która posiada bardzo bogaty ekosystem, co daje ogromne możliwości wyboru bibliotek i~narzędzi wspomagających prace programistyczne.

\section {Serwer}

Całość systemu powinna zostać wykonana w~sposób spełniający normy bezpieczeństwa charakterystyczne dla tego typu aplikacji biznesowych. Każdy zasób dostępny z~zewnątrz musi być chroniony, tzn. możliwy do interakcji tylko dla uwierzytelnionych użytkowników. Ochrona tych elementów i~dostarczenie bazującej na nich logiki biznesowej w~formie możliwej do użycia z~poziomu aplikacji mobilnej oraz przeglądarki internetowej będą głównymi zadaniami części serwerowej systemu.

\subsection{Baza Danych}
\label{sec:bazaDanych}

Charakter tworzonej aplikacji wymaga, aby dane jakie będą tworzyć i~modyfikować użytkownicy były zapamiętane pomiędzy sesjami klienta, a~także muszą być dostępne i~spójne, niezależnie od tego czy osoba korzystająca z~usługi łączy się z~nią każdorazowo przy pomocy tego samego komputera. Dane uzupełniane w~systemie muszą być również identyczne dla każdego użytkownika, to znaczy muszą oni mieć możliwość przeglądania treści dodawanych przez inne osoby. Z~tego powodu niezbędne jest przetrzymywanie ich po stronie serwera za pomocą bazy danych.

\subsubsection{System zarządzania relacyjnymi bazami danych}

Spośród różnych dostępnych typów baz danych zdecydowano się na relacyjną bazę \emph{PostgreSQL}. Cechuje się ona dużą niezawodnością i~jest w pełni darmowa nawet w~przypadku użytku komercyjnego. Jej popularność, a~zatem i~duże wsparcie ze strony społeczności, będzie również zaletą w razie wystąpienia nieoczekiwanych problemów.

Baza danych PostgreSQL udostępnia również graficzny interfejs do zarządzania o~nazwie \emph{pgadmin}. Przy jego pomocy nadzorowanie i~modyfikacja danych testowych będzie znacznie ułatwionym zadaniem.

\subsubsection{Mapowanie obiektowo-relacyjne}

W relacyjnej bazie danych, jak jej nazwa wskazuje, wartości przetrzymywane są w~sposób relacyjny, podczas gdy w~języku Java oprogramowanie tworzy się w~sposób obiektowy. Model relacyjny można przyrównać do prostej postaci tabularnej, gdzie dane przetrzymywane są bez informacje o~typach innych danych powiązanych z~nimi. W~odróżnieniu model obiektowy pozwala na tworzenie ścisłych powiązań pomiędzy różnymi obiektami, co sprawia że przemieszczanie się po ich grafie jest dużo prostsze i~bardziej naturalne.

Dostęp do bazy danych w~języku Java zapewniony jest przez technologię JDBC\footnote{Java DataBase Connectivity}, która pozwala na wykonywanie skomponowanych przez siebie zapytań SQL, będących z~punktu widzenia kompilatora jedynie ciągiem znaków. Z~tego powodu bez dodatkowych narzędzi nie jest możliwa kontrola typów i~ poprawności zapytań co może doprowadzić do nieobliczalnych błędów oraz trudności w rozwoju i~ utrzymaniu kodu.

Mapowanie obiektowo-relacyjne rozwiązuje ten problem poprzez automatyczne zarządzanie niższą warstwą trwałości na podstawie zdefiniowanego przez programistę interfejsy obiektowego. Narzędzia generowania schematów baz danych tworzą całą strukturę, którą konfiguruje się przy pomocy adnotacji encji, będących zwykle prostymi obiektami POJO\footnote{Plain Old Java Object}. Tak utworzone API jest gotowe do wykorzystania jako warstwa trwałości danych.

Odwzorowanie modelu relacyjnego na obiektowy nie jest prostym zadaniem, ze względu na duże różnice między nimi. W szczególności największą trudność sprawiają problemy odwzorowania dziedziczenia, identyczności danych oraz powiązań między obiektami. Dlatego też bardzo istotne jest wybranie odpowiedniego rozwiązania, które w~pełny sposób obsługuje wymienione przypadki. Zdecydowano się na bibliotekę Hibernate, która oprócz własnego interfejsu implementuje również standard \emph{JPA} dostarczany wraz z \emph{Java EE}. Wykorzystując tę bibliotekę jako jego implementację, podmiana jej na inną nie przyniesie żadnych problemów co pozytywnie wpływanie na utrzymanie projektu. Więcej na temat mapowania obiektowo-relacyjnego można przeczytać w~\cite{HORM}.

\subsubsection{Schemat bazy danych}

Dane najbardziej wrażliwe na zmiany to takie, które pochodzą z~zewnątrz. Zalecenia Narodowego Funduszu Zdrowia do definiowania wykonanych przez lekarza prac mogą ulegać zmianie, więc bardzo istotny jest przemyślany system aktualizacji. Aplikacja webowa nie stanowi tu problemu, ponieważ nie jest instalowana po stronie klienta, a~jedynie renderowana na podstawie danych uzyskiwanych z~serwera, wobec czego wystarczająca będzie jego aktualizacja. W~przypadku aplikacji mobilnych, logika interpretacji danych i~ich renderowanie będzie znajdować się po stronie telefonu komórkowego. Dobrym podejściem byłoby uniezależnienie się od statycznych wartości, możliwych do uzupełniania w~aplikacji, takich jak obszary leczenia, czy typ rozpoznania. Modyfikacja bazy tych zasobów nie powinna zmuszać wszystkich, korzystających z~niej lekarzy do pobierania aktualizacji, zwłaszcza że nie jest to konieczne. Nie jest to również bez znaczenia w~utrzymaniu produktu - wprowadzanie takich aktualizacji w~kodzie aplikacji nie będzie wcale konieczne, ponieważ zostaną one zastąpione przez wykonanie prostego skryptu aktualizującego zawartość bazy danych po stronie serwera.

Na podstawie zaprojektowanej obiektowo warstwy trwałości, która wykorzystana zostanie w~logice biznesowej aplikacji wygenerowano schemat bazy danych przedstawiony na rysunku \ref{fig:dbschema}. Znaczenie tabeli ma swoje odwzorowanie w~obiektach modelu, które zostały bardziej przybliżone w~podrozdziale \ref{sec:modele} przy okazji omawiania szczegółów implementacji.

\begin{figure}[h!]
	\centering
	\includegraphics[height=\textheight * 4/5]{dbschema}
	\caption{Graficzna reprezentacja schematu bazy danych wygenerowana przy pomocy aplikacji \emph{SchemaSpy}}.
	\label{fig:dbschema}
\end{figure}

\subsection{Web Service}

Implementowany system wymaga stworzenia aplikacji mobilnej, która będzie korzystać z tego samego zbioru danych co aplikacja webowa. Warstwa trwałości, opisana w podrozdziale \ref{sec:bazaDanych}, znajdować się ma na serwerze, wobec czego należy opracować sposób dostępu do tych danych, osiągalny z~poziomu klienta mobilnego. Elementem udostępniającym te dane będzie Web Service.

\subsubsection{Protokół}

Istnieją dwa wiodące standardy tworzenia Web Service'ów: RESTful\footnote{REpresentational State Transfer} oraz SOAP\footnote{Simple Object Access Protocol}. Obydwa rozwiązania mają swoje wady i~zalety, jednak wybór odpowiedniego musi być ściśle dopasowany do potrzeb realizowanego projektu, w czym pomoże krótkie wprowadzenie do ich koncepcji.

\paragraph{RESTful}

Web Service typu RESTful oparty jest na wzorcu architektury \emph{REST}, zaproponowanym przez jednego z~autorów protokołu HTTP - Roy'a Fieldinga. W~\cite{RFD} jego autorstwa czytamy, że główną abstrakcją informacji jest zasób, którym może być wszystko co da się nazwać: dokument, obrazek, usługa udzielająca informacji o pogodzie, kolekcja innych zasobów, obiekt rzeczywisty (np. osoba) itp. Wokół tych zasobów, tworzących nieskończony zbiór, zdefiniowane są skończone akcje, określone przez metody protokołu HTTP. Taki styl architektury nosi nazwę \emph{Resource Oriented Architecture}.

Usługi tego typu są bardzo silnie powiązane z~protokołem HTTP, to znaczy wykorzystują jego pola do przesyłania danych charakterystycznych dla usługi, a~nie transportu zagnieżdżonego protokołu. Dla przykładu zapytanie pobierające dane pewnego zasobu o~określonym identyfikatorze, może skutkować w~odpowiedzi \emph{HTTP 404 Not Found}, jeśli odpytywany zasób nie istnieje. W przypadku gdyby protokół HTTP był wykorzystywany jedynie do komunikacji, odpowiedzią byłoby \emph{200 OK}, a~status błędu zakodowany zostałby wewnątrz transportowanych danych.

Dzięki takiemu podejściu jedyne co jest potrzebne do konsumpcji usługi \emph{RESTful} to klient protokołu \emph{HTTP}.

\paragraph{SOAP}

Protokół \emph{SOAP} według \cite{W3Soap} zaprojektowany został mając na uwadze prostotę i~rozszerzalność. Do transportu danych zwykle wykorzystywany jest protokół \emph{HTTP}, ale jego nagłówki nie są wykorzystywane do opisu wyników operacji czy parametryzowania zapytań. W~tym wypadku protokół ten wykorzystywany jest jedynie do przekazania danych, opisywanych przy wykorzystaniu własnego standardu, opartego na języku \emph{XML}. Należy jednak podkreślić, że \emph{SOAP} nie jest silnie powiązany z~protokołem \emph{HTTP} i~do komunikacji mogą zostać wykorzystane inne standardy.

Interfejs \emph{Web Service'u SOAP} opisywany jest według kontraktu, który jest plikiem \emph{WSDL} zapisanym w formacie XML. Kontrakt ten musi zostać opublikowany, lub przesłany do osób zainteresowanych konsumpcją usługi. Ręczne użytkowanie, wbrew temu co sugeruje nazwa i~założenia, jest na tyle skomplikowane, że w~większości przypadków do efektywnej pracy niezbędne są narzędzia pozwalające na generowanie kodu strony klienckiej lub serwerowej na podstawie kontraktu \emph{WSDL}. W~przeciwnym wypadku konieczne jest dogłębne poznanie standardu, aby móc parsować i~tworzyć wiadomości \emph{SOAP}.

W odróżnieniu od podejścia \emph{REST}, protokół \emph{SOAP} jest zorientowany na usługę (\emph{Service Oriented Architecture}), czyli akcje możliwe do wykonania, a~nie zasoby.

\paragraph{Wybór i uzasadnienie}

Nakład pracy potrzebny do użycia \emph{SOAP} jako usługi dedykowanej dla klienta mobilnego jest niewspółmiernie wyższy od wykorzystania \emph{RESTful}. Styl architektury zorientowany na zasoby narzuca pewne ramy, aby wpasować się w~możliwości protokołu \emph{HTTP}, ale dzięki temu każdy Web Service, który ich przestrzega jest osiągalny przy pomocy zwykłego klienta \emph{HTTP}. Większość usług podążających tą drogą ma jasny interfejs nie wymagający większej dokumentacji, poza wymienieniem dostępnych zasobów, ponieważ metody HTTP wykorzystywane do wykonywania na nich operacji zwykle dobierane są w~sposób jednakowy, zgodnie z~zalecanymi standardami.

W~przypadku implementowanego systemu zdecydowanie lepszą drogą będzie skorzystanie z~usługi typu \emph{RESTful}. Jest to również technologia oficjalnie zalecana do użycia na platformie Android. Ze względu na to, że opiera się ona na stylu architektury REST, który jest sposobem definiowania zasobów przeznaczonym dla WWW, taką usługę będzie można wykorzystać także dla drugiego tworzonego modułu klienckiego - strony internetowej, co byłoby znacznie trudniejsze do osiągnięcia przy wykorzystaniu \emph{SOAP}. Możliwość wykorzystania wspólnego interfejsu między tym dwoma modułami znacznie ułatwi prace rozwojowe i~utrzymanie projektu.

\subsubsection{Serializacja}

Jedną z~zalet wykorzystania \emph{Web Service'ów} jest możliwość rozwijania produktu w~innych technologiach po dwóch różnych jego stronach - klienckiej i serwerowej. Powoduje to jednak, że przesyłane dane muszą być zapisane w~notacji niezależnej od języka programowania. W~tym celu stosuje się serializację obiektów do jednego z~formatów - zwykle jest to \emph{JSON} lub \emph{XML}.

W~języku Java istnieje wiele rozwiązań umożliwiających automatyczną konwersję obiektów typu \emph{POJO} do jednego z nich. W~aplikacji tworzonej na potrzeby pracy zdecydowano się na bibliotekę \emph{Jackson}, obsługującą format \emph{JSON}.

\subsubsection{API}

Web Service jest elementem, który będzie oddzielał warstwę prezentacji od logiki. Należy wobec tego zadbać, aby wszystkie elementy, które do tej warstwy należą, czyli w~tym wypadku klient webowy i~mobilny, miały możliwość wygodnego korzystania z~interfejsu RESTowego. Zaletą Web Service'ów RESTful jest ich prostota. Jako że opierają się silnie na HTTP, elementem wystarczającym do ich konsumpcji jest możliwość wykorzystania klienta tego protokołu. Dzięki temu nie sprawi to problemu w~użytkowaniu go również po stronie aplikacji mobilnej. Między wykorzystanym w~nim kliencie protokołu HTTP, a przeglądarką internetową istnieją jednak pewne różnice, które trzeba mieć na uwadze przy projektowaniu interfejsu.

Interfejsy RESTful zorientowane są na zasoby, odpowiednim podejściem będzie więc zaczęcie od ich identyfikacji. W~tworzonej aplikacji są to wszelkie klasy danych, do których dostęp udzielony zostanie użytkownikowi. Interfejs nie musi być wersjonowany, ponieważ jest on tylko do zastosowania wewnętrznego i~nie będzie upubliczniany. Moduł webowy oraz mobilny są jego jedynymi klientami i~stanowią integralną część aplikacji. Z~tego względu pierwszy człon adresu URL będzie od razu jednym z~zasobów, któremu zwykle przydziela się formę liczby mnogiej:
\begin{itemize}
	\item /patients
	\item /doctors
	\item /visits
	\item /areas
	\item /diagnoses
	\item /treatments
\end{itemize}

Zgodnie z~ogólnie przyjętą praktyką, o~której można przeczytać w \cite{WApiD}, dla zróżnicowania typów operacji na zasobach wykorzystuje się następujące metody \emph{HTTP}:
\begin{description}
	\item[GET] odczytywanie
	\item[PUT] tworzenie nowej instancji
	\item[POST] aktualizowanie
	\item[DELETE] usuwanie
\end{description}

Posługując się zasobem pacjenta jako przykładem, wyróżnić można następujące zapytania:
\begin{description}
\item[GET /patients] odczyt listy pacjentów
\item[GET /patients/\{id\}] odczyt pacjenta o~identyfikatorze \emph{\{id\}}
\item[POST /patients] stworzenie nowego pacjenta
\item[PUT /patients/\{id\}] aktualizacja pacjenta o~identyfikatorze \emph{\{id\}}
\item[DELETE /patients/\{id\}] usunięcie pacjenta o~identyfikatorze \emph{\{id\}}
\end{description}

Jak dalej zaleca \cite{WApiD} wszelkie dodatkowe informacje, uściślające sposób wykonania operacji, powinny być przekazywane w~parametrach URL, aby nie zanieczyszczać nimi API. Przykładowo filtrowanie listy wizyt dla dnia 22.08.2014 i~aktualnie zalogowanego lekarza przybierze następującą postać:
\begin{lstlisting}
GET /visits?showOnlyMine=true&fromDate=22.08.2014&toDate=22.08.2014
\end{lstlisting}

Niestety nie wszystkie z~wymienionych metod \emph{HTTP} są zawsze implementowane w~przeglądarkach. Dla aplikacji mobilnej nie stanowi to problemu, jednak warto zachować wspólne API dla obydwu modułów, więc adaptacja interfejsu dla potrzeb WWW wpłynie również na klienta dedykowanego dla telefonów komórkowych. Problematycznymi metodami są \emph{PUT} oraz \emph{DELETE}, więc zostaną zastąpione metodą \emph{GET}. Do nazw zasobów przekształconych metod dodano sufiksy \emph{-create} oraz \emph{-delete}, aby móc rozróżnić intencje klienta.
Ostateczny interfejs przedstawia listing \ref{lst:routes} zawierający fragment pliku \emph{routes} stosowanego frameworka.

\begin{lstlisting}[caption={Fragment pliku \emph{routes} zawierającego mapowanie wzorców URL interfejsu RESTful do wywoływanych metod kontrolerów w \emph{Play Framework}}, label={lst:routes}]
GET     /patients                                               controllers.PatientController.list(page: Int ?= 0, query: String ?= null)
GET     /patients/:id                                           controllers.PatientController.get(id: Long)
GET     /patients-create                                        controllers.PatientController.create()
POST    /patients                                                 controllers.PatientController.save()
GET     /patients-delete/:id                                     controllers.PatientController.remove(id: Long)

GET     /doctors                                                 controllers.DoctorController.list(page: Int ?= 0)
GET     /doctors/:id                                             controllers.DoctorController.get(id: Long)
GET     /doctors-create                                          controllers.DoctorController.create()
POST    /doctors                                                   controllers.DoctorController.save()
GET     /doctors-delete/:id                                      controllers.DoctorController.remove(id: Long)

GET     /visits                                                  controllers.VisitController.list(page: Int ?= 0, onlyMine: Boolean ?= false, fromDate: String ?= null, toDate: String ?= null, pId: Long ?= -1)
GET     /visits/:id                                              controllers.VisitController.get(id: Long)
GET     /patients/:pId/visits-create                             controllers.VisitController.create(pId: Long)
POST    /visits                                                  controllers.VisitController.save()
GET     /visits-delete/:id                                       controllers.VisitController.remove(id: Long)

GET     /areas                                                   controllers.AreaController.list()
GET     /diagnoses                                               controllers.DiagnosisController.list()
GET     /treatments                                              controllers.TreatmentController.list()
\end{lstlisting}

\section{Aplikacja webowa}

Aplikacja webowa powinna pozwalać na zrealizowanie kompletu funkcjonalności przewidzianych w~systemie. Ze względu na większy komfort obsługi, spowodowany przeciętnie większym rozmiarem wyświetlaczy w~komputerach stacjonarnych niż w~telefonach komórkowych i~tabletach oraz możliwością skorzystania z~urządzeń wejściowych, takich jak klawiatura czy myszka, jest przewidziana jako docelowe narzędzie pracy wnoszonej przez użytkowników systemu.

W~zakres aplikacji powinno wchodzić:
\begin{itemize}
	\item przeglądanie bazy pacjentów z~opcją filtrowania po imieniu, nazwisku lub numerze PESEL
	\item zarządzanie bazą pacjentów, tzn. ich dodawanie, usuwanie i~edycja
	\item możliwość planowania wizyt z~poziomu widoku pacjenta
	\item widok do przeglądania listy wizyt, umożliwiający filtrowanie po dacie oraz obecnie zalogowanym lekarzu
	\item możliwość podglądu, edycji i~usunięcia wybranej wizyty
	\item zarządzanie bazą lekarzy, czyli użytkowników systemu, a~w~szczególności przeglądanie, edycja, usuwanie oraz możliwość zmiany hasła
	\item udogodnienia pozwalające na realizację najczęściej wykonywanych operacji przy pomocy jednego kliknięcia, zamiast żmudnego powtarzania tych samych czynności, a~w~szczególności:
	\begin{itemize}
		\item możliwość przeglądania wszystkich wizyt danego pacjenta z poziomu jego widoku
		\item skrót służący do przeglądania wizyt na aktualny dzień przypisanych do zalogowanego lekarza
	\end{itemize} 
\end{itemize}

\subsection{Dobór technologii}

Na platformę Java istnieje wiele kompleksowych narzędzi, takich jak Google Web Toolkit czy Vaadin, pozwalających na konstrukcję strony internetowej przy pomocy tego języka, bez konieczności zapoznawania się z~technologiami uruchamianymi po stronie klienta w~przeglądarce internetowej. Takie podejście niesie jednak ze sobą sporo ograniczeń wobec mnogości rozwiązań pokroju jQueryUI, czy Ext JS, niezależnych od strony serwerowej. Rozdzielenie tych dwóch warstw, choć wymaga większej wiedzy, zwykle jednak również skutkuje we wzroście wydajności w~stosunku do języka Java kompilowanego do JavaScript, co jest oferowane przez rozwiązania tego typu.

Zdecydowano się więc na oddzielenie strony serwerowej (Back end) od klienckiej (Front end) co pozwoli dokonać niezależnego wyboru dla każdej z~nich, zwiększając wachlarz możliwości.

\subsubsection{Back end}

Framework umożliwiający implementację strony serwerowej, powinien pozwalać na definiowanie szablonów stron HTML. Dzięki temu można będzie uniezależnić się od strony klienckiej, dla której wybierze się technologie wspomagające wyświetlanie treści użytkownikom w~ich przeglądarkach internetowych.

Jednym z~takich frameworków jest \emph{Play Framework}, który wpasowuje się również w~inne założenia postawione w~tym rozdziale, a~w~szczególności:

\begin{itemize}
	\item umożliwia wykorzystanie \emph{Hibernate} jako implementacji \emph{JPA}
	\item \emph{Jackson} jest domyślną biblioteką do serializacji w~notacji \emph{JSON}, ale istnieje również możliwość skorzystania z~innych
	\item pozwala na proste mapowanie wzorców \emph{URL} do metod kontrolerów, tzn. ułatwi w~znaczny sposób implementację \emph{Web Service'u} typu \emph{RESTful}
\end{itemize}

Z wymienionych wyżej powodów, zdecydowano że \emph{Play Framework} będzie dobrym wyborem dla serwerowej strony implementowanego systemu.

\subsubsection{Front end}
Dzięki odseparowaniu strony klienckiej od \emph{Javy}, można dla niej dobrać technologie przeznaczone specjalnie do rozwoju stron WWW, będącego bardzo prężnie rozwijającą się dziedziną w~dobie internetu, co znacznie powiększa możliwości wyboru.

Jako baza dla witryny posłuży kod \emph{HTML}, wzbogacony przez następujące frameworki, języki i~biblioteki:

\begin{description}
\item[JavaScript] do zapewnienia dynamicznej zawartości
\item[CSS] jako język definiujący styl strony
\item[jQuery] pomagające w konstruowaniu zapytań \emph{AJAX}, obsłudze zdarzeń oraz modyfikacji struktury dokumentu
\item[Twitter Bootstrap] do strukturyzacji strony i ujednoliconego wyglądu komponentów
\item[Glyphicons] jako pakiet ikon dostępny wraz z \emph{Twitter Bootstrap}
\end{description}

\section{Aplikacja mobilna}

Aplikacja przeznaczona na telefon komórkowy powinna mieć mniejszy zakres działań od aplikacji webowej. Przeciętny rozmiar urządzeń mobilnych i~brak zewnętrznej klawiatury oraz myszki w~zestawie\footnote{Platformy mobilne pozwalają na podłączenie zewnętrznych urządzeń wejściowych poprzez technologię bluetooth lub USB, jednak nie jest to częsta praktyka.} ogranicza swobodę korzystania z~aplikacji, a~w~szczególności pisania długich tekstów czy też przełączania się pomiędzy różnymi oknami aplikacji, co w~przeglądarce internetowej da się łatwo osiągnąć przy pomocy kart.

Głównym zadaniem aplikacji mobilnej powinno być umożliwienie wykonania szybkich akcji, nawet w~obecności pacjenta, bez konieczności podchodzenia do komputera. W~szczególności autor ma na myśli automatyczne filtrowanie wizyt dla zalogowanego lekarza i~aktualnego dnia, oraz nie zanieczyszczanie interfejsu zbyt skomplikowanymi operacjami, takimi jak zarządzanie innymi lekarzami, które dużo wygodniej będzie zrealizować przy pomocy aplikacji webowej.

W zakres aplikacji mobilnej powinno więc wchodzić:

\begin{itemize}
	\item Przeglądanie bazy pacjentów
	\item Dodawanie i~edycja pacjenta
	\item Przeglądanie wizyt z~automatycznym ograniczeniem do aktualnego dnia i~zalogowanego lekarza
	\item Edytowanie wizyt
	\item Konfiguracja usługi klienta \emph{Web Service'u}, to znaczy możliwość określenia:
	\begin{itemize}
		\item adresu IP i~port serwera
		\item nazwy i~hasła użytkownika
	\end{itemize}
	Po poprawnej konfiguracji, logowanie w usłudze i~zarządzanie sesją powinno następować automatycznie, bez zmuszania użytkownika do ponownego podawania danych nawet po długim okresie bezczynności. Dane konfiguracyjne muszą być trwale zapisywane w~aplikacji, tzn. zapamiętane pomiędzy sesjami użytkowania.
\end{itemize}

Pozostałe czynności, takie jak zarządzanie bazą lekarzy, czy planowanie wizyt dla pacjentów powinny zostać wykonane po stronie aplikacji webowej.
%dodawanie wizyt nie może być zrobione, bo nie można ich będzie przeglądać chyba że będą na aktualny dzień

\subsection{Platforma}

Dostępne na rynku mobilne systemy operacyjne nie pozwalają na przenośność aplikacji pomiędzy nimi, a~więc przy wyborze jednego z~nich warto skupić się na potrzebie potencjalnego klienta, a~nie wygodzie w~implementacji. Zgodnie z~danymi udostępnionymi w~\cite{AMS} platforma \emph{Android} w~roku 2014 zajmuje pierwsze miejsce na rynku europejskim z~udziałem \emph{73,3\%}, na drugim miejscu jest produkt \emph{Apple} z~wynikiem 16,6\%, a~na trzecim \emph{Windows} z~8,1\% udziałów. Na rynku amerykańskim sytuacja \emph{Apple} poprawia się wyrównując walkę z produktem \emph{Google}, jednak tworzona aplikacja dostosowana jest dla polskiego odbiorcy, więc statystyki zebrane w~Europie są tutaj bardziej znaczące.

Platforma \emph{Android} pozwala również na implementowanie aplikacji w~języku Java. Ze względu na dużą popularność, co sprawi że gotowy produkt będzie mógł trafić do jak największej liczby lekarzy oraz zachowanie spójności z~technologią Java, będzie ona odpowiednim wyborem dla tworzonej aplikacji.

Wydzielenie logiki w~postaci \emph{Web Service'u} pozwoli także w~przyszłości rozwinąć system o~inne platformy mobilne.

\subsection{Klient WebService}

Dzięki wybraniu RESTful jako sposobu implementacji \emph{Web Service'u}, komunikacja z~nim po stronie aplikacji mobilnej jest zadaniem znacznie ułatwionym. Problem konsumpcji usługi ogranicza się do wyboru odpowiedniego klienta protokołu HTTP. W implementowanym systemie zdecydowano się na wykorzystanie w tym celu klasy \emph{AndroidHttpClient} implementującej interfejs \emph{HttpClient} znanej w~świecie Javy organizacji \emph{Apache}.

\section{Narzędzia programistyczne}

Realizowany system dzieli się na dwa główne projekty: aplikację mobilną oraz webową, zawierającą w~sobie stronę serwerową. \emph{Play Framework} jest niezależny od środowiska programistycznego, więc jako IDE przeznaczone do rozwoju drugiego z~wymienionych fragmentów wykorzystane zostanie środowisko Eclipse, używane na co dzień przez autora pracy.

Platforma \emph{Android} również nie narzuca wyboru środowiska, ale ze względu na rozdzielenie tych dwóch fragmentów abstrakcyjną warstwą Web Service'u, korzyść z~użytkowania wspólnego IDE byłaby niewielka, ze względu na brak bezpośredniego połączenia pomiędzy projektami programistycznymi. Zalety z~użytkowania środowiska dedykowanego tej platformie, tzn. Android Studio opartego na środowisku IntelliJ, przewyższają ujednolicenie projektu, oferując między innymi automatyczną integrację z~Android SDK i~zaawansowane narzędzia refaktoryzacji, dostosowane do projektów tego typu.

Ręczne zarządzanie bibliotekami programistycznymi bywa bardzo kłopotliwym zadaniem oraz zwiększa zapotrzebowanie miejsca na dysku w~systemie kontroli wersji. Dodatkowo wymusza wybór środowiska programistycznego przy projekcie kolaboracyjnym, co jednak tutaj nie stanowi projektu ze względu na jednego autora systemu. Niemniej jednak zdecydowano się na wykorzystanie systemów zarządzania zależnościami, w~celu zwiększenia wygody programowania. Niestety \emph{Play Framework} oraz \emph{Android} mają różne zalecenia jeśli chodzi o ich wybór. Dzięki całkowitemu oddzieleniu tych projektów od siebie nie przyniesie to jednak kłopotu, więc wybranymi systemami będą odpowiednio \emph{Sbt} oraz \emph{Gradle}.

%----------------------------------------------------------------------------

\chapter{Implementacja}
\label{cha:implementacja}

%TODO: mobile? klient ws (logowanie), propertiesy (persistence), appcompat

Podczas implementacji systemu tworzonego w~ramach pracy dołożono wszelkich starań, aby był on zgodny obowiązującymi normami bezpieczeństwa oraz praktykami ułatwiającymi rozwój i~utrzymanie produktu. W~tworzeniu aplikacji biznesowych istnieje wiele problemów i~pułapek, z~którymi zwykle można poradzić sobie na więcej niż jeden sposób. W dalszej części rozdziału przedstawione zostaną najważniejsze praktyki wraz z~motywacją ich użycia, dotyczące różnego rodzaju aplikacji, ale dopasowane do realizowanego projektu.

\section{Wzorzec MVC}
\label{sec:wzorzecMVC}

W~celu zwiększenia czytelności i~elastyczności projektu warto zastosować wzorzec projektowy \emph{Model View Controller}. Jego głównym celem jest odseparowanie warstwy danych od prezentacji, aby zwiększyć możliwości ponownego wykorzystania komponentów do różnych celów. Model w~\cite{GoF} tłumaczony jest jako obiekt aplikacji, widok jako jego reprezentacja w~graficznym interfejsie użytkownika, a~kontroler to spójnik definiujący sposób reakcji na akcje użytkownika z poziomu interfejsu.

Do aktualizacji widoku na podstawie modyfikacji wprowadzanych do modelu \emph{MVC} wykorzystuje wzorzec \emph{Obserwator}. Kiedy zmienią się dane modelu, informuje on o~tym obserwujące go obiekty, na przykład różne widoki.

W aplikacjach webowych przypadek jest o~tyle szczególny, że to klient, któremu renderowany jest widok odpytuje serwer o~aktualizacje, a~model nie ma możliwości wpływać na wyświetlane dane. Zastosowanie obserwatorów nie będzie więc miało miejsca w adaptacji wzorca do potrzeb WWW\footnote{World Wide Web}.

\emph{Play Framework} z~góry narzuca stosowanie \emph{Model View Controller} tworząc pakiety odpowiadające składowym wzorca. Tworzony system składa się z~części webowej i~mobilnej, więc możliwość wykorzystania tych samych składników dla obydwu modułów będzie dużą zaletą. Schematy zaprezentowane w dalszej części, dopasowane do charakterystyki projektu bazując na \cite{PfMC}, przedstawiają rozdzielenie poszczególnych elementów wzorca \emph{Model View Controller} pomiędzy tymi platformami.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth * 4/5]{MVC-WEB}
	\caption{Schemat MVC z wyszczególnieniem platformy webowej}
	\label{fig:mvc-web}
\end{figure}

Na rysunku \ref{fig:mvc-web} przedstawiono sposób komunikacji pomiędzy warstwami najwyższego poziomu dla aplikacji webowej. Użytkownik wpisując w~przeglądarce adres URL, pod którym upubliczniona jest aplikacja lub klikając w odnośniki wysyła żądania HTTP do serwera. Przed przekazaniem ich do kontrolera, następuje sprawdzenie autentyczności użytkownika opisane szerzej w rozdziałach \ref{sec:uwierzytelnianie} oraz \ref{sec:ochronaWybranychZasobow}. Jeśli dane uwierzytelniające są niepoprawne użytkownik przekierowywany jest do strony logowania. W~przeciwnym wypadku żądanie trafia do kontrolera, który je analizuje i~w~razie potrzeby aktualizuje model. Następnie na podstawie szablonów, które wypełniane są danymi modelu renderowany jest widok w postaci dokumentu HTML. Wynik przekazywany jest z~powrotem do klienta w~odpowiedzi HTTP, na podstawie której przeglądarka wyświetla stronę i~pozwala użytkownikowi na podjęcie kolejnych akcji.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth * 4/5]{MVC-MOBILE}
	\caption{Schemat MVC z wyszczególnieniem platformy mobilnej}
	\label{fig:mvc-mobile}
\end{figure}

%TODO? Odnośnik do bib z WebView?
Aplikacje Android nie wykorzystują dokumentów HTML do prezentacji\footnote{Platforma Android pozwala na wyświetlenie dokumentów HTML przy pomocy klasy \emph{WebView}, jednak nie jest to standardowe podejście projektowania aplikacji}, więc widoki, które wyświetlane będą na telefonie komórkowym muszą zostać zaprojektowane od nowa, wykorzystując rozwiązania dostępne na tę platformę. Rysunek \ref{fig:mvc-mobile} przedstawia komunikację pomiędzy aplikacją mobilną a~serwerem. Jak widać na schemacie widok przeznaczony dla aplikacji webowych nie bierze już udziału w~wyświetlaniu treści. Aplikacja mobilna zawiera jego własną wersję, która odwzorowuje funkcjonalności osiągalne za pomocą strony internetowej, ale jest zrealizowana przy pomocy \emph{Android SDK}. Ze względu na to, że cała warstwa prezentacji musi znajdować się po stronie klienta w postaci aplikacji mobilnej, odpowiedzi zwracane przez kontroler powinny zwracać jedynie czystą reprezentację danych, dlatego zdecydowano się na format JSON. Innymi słowy dane, które w~przypadku klienta webowego były przekazywane do widoku celem przygotowania gotowego do wyświetlenia dokumentu i~zwrócenia go w~odpowiedzi, w~tym przypadku są przekazywane bezpośrednio do klienta mobilnego, który samodzielnie wypełnia nimi własne widoki.

Na przedstawionych schematach widać, że rozdwojenie usługi na platformę mobilną i~webową zaczyna się dopiero za warstwą kontrolera, który razem z~modelem jest dla nich częścią wspólną. Jedyną różnicą pomiędzy obydwoma interfejsami stanowią widoki, co było celem, który udało się osiągnąć.

\section{Modele}
\label{sec:modele}

W~tworzonej aplikacji można wyróżnić następujące modele:
\begin{description}
\item[Patient]
	Model pacjenta przychodni, składający się z~następujących danych:
	\begin{itemize}
		\item imię
		\item nazwisko
		\item numer PESEL
		\item numer telefonu kontaktowego
		\item nazwa ulicy adresu zamieszkaniu
		\item numer domu
		\item numer mieszkania
		\item miejscowość
		\item kod pocztowy
	\end{itemize}
\item[Doctor]
	Model lekarza, czyli docelowego użytkownika aplikacji, agregujący następujące dane:
	\begin{itemize}
		\item imię 
		\item nazwisko
		\item nazwa użytkownika
		\item hasło
		\item sól hasła (patrz \ref{sec:sol})
		\item adres e-mail
	\end{itemize}
\item[Visit]
	Model wizyty, składający się z:
	\begin{itemize}
		\item lekarza wykonującego leczenie
		\item pacjenta poddawanego leczeniu
		\item daty i~czasu wizyty
		\item listy wykonanych prac
		\item dodatkowych informacji w postaci notatek
	\end{itemize}
\item[Work]
	Praca wykonana w~ramach wizyty, w~której istnieje możliwość określenia:
	\begin{itemize}
		\item obszar w~jamie ustnej dotyczący wykonanej pracy
		\item rozpoznanie
		\item podjęte leczenie
	\end{itemize}
	W~aplikacji objęto jedynie przykładowe wartości odpowiadające powyższym składnikom wykonanej pracy, ale dzięki wydzieleniu obszaru w~bazie danych służącemu do ich przetrzymywania, istnieje możliwość aktualizacji dopasowując się do potrzeb danego gabinetu bez konieczności wprowadzania zmian w~kodzie źródłowym. Przykładowe wartości zgodne z~zaleceniami NFZ znaleźć można w~\cite{DzU13} oraz \cite{ICD9}.
\item[Area]
	Lista możliwych obszarów leczenia.
\item[Diagnosis]
	Lista możliwych obszarów rozpoznań.
\item[Treatment]
	Lista możliwych obszarów leczeń.
\item[Token]
	Token czasowy umożliwiający reset hasła, w którego skład wchodzą:
	\begin{itemize}
		\item lekarz, będący użytkownikiem, który chce zmienić hasło
		\item czas utworzenia żądania, który posłuży do sprawdzenia ważności tokenu
	\end{itemize}
\item[Session]
	Sesja, jaką nawiązuje użytkownik podczas logowania składająca się z:
	\begin{itemize}
		\item zalogowanego w sesji lekarza
		\item daty i~czasu ostatniej aktywności w~sesji, do obsługi funkcji automatycznego wylogowania w przypadku zbyt długiej przerwy od ostatnio otrzymanego żądania
	\end{itemize}
\end{description}

\section{Widoki}

%jedyne miejsce zmienne dla urządzeń!!

\subsection{Web}

\subsection{Mobile}

\subsection{User Experience}
układ formularzy, komunikaty po akcjach (do zrobienia?), walidacja pól, kalendarz, wyszukiwarka, paginacja, (walidacja PESEL??)
%----------------------------------------------------------------------------

\section{Kontrolery}

W \emph{Play Framework} kontrolery stanowią jednocześnie interfejs Web Service'u typu REST. Jest to również jedyne miejsce, gdzie możliwe jest użycie adnotacji \emph{@Transactional}, która jak wskazuje nazwa służy do oznaczenia zakresu transakcji bazodanowych. W~związku z~tym, wszystkie metody kontrolerów, które zostały udostępnione za pośrednictwem Web Service'u zostały oznaczone tą adnotacją, aby w~razie wystąpienia problemu nastąpił \emph{rollback} obejmujący wszystkie działania na bazie danych od początku wywołania metody przez klienta.

Głównym zadaniem większości ze stworzonych kontrolerów jest umożliwienie aktualizacji i~prezentacji modeli. Implementują one metody pozwalające na:

\begin{itemize}
	\item Wyświetlenie pojedynczego zasobu
	\item Wyświetlenie listy zasobów
	\item Aktualizację, lub utworzenie zasobu
	\item Usunięcie zasobu
\end{itemize}

Wymienione funkcjonalności dotyczą następujących kontrolerów, których nazewnictwo odpowiada modelom na jakich operują:

\begin{itemize}
	\item DoctorController
	\item PatientController
	\item VisitController
\end{itemize}

Szczególnym przypadkiem są \emph{AreaController}, \emph{DiagnosisController} oraz \emph{TreatmentController}, które umożliwiają jedynie zwrócenie listy zasobów, czyli możliwych wyborów, którymi wypełnione zostaną kontrolki rozwijanej listy (\emph{Combo box}). Takie podejście pozwoli na wprowadzenie aktualizacji, zwiększając lekarzom możliwości wyboru leczeń i diagnoz, bez potrzeby ingerencji w kod źródłowy aplikacji. Wyjątkowym przypadkiem jest również kontroler \emph{Application} realizujący usługi z zakresu uwierzytelniania, zarządzania sesją i~resetu hasła.

Zgodnie z~ustaleniami omówionymi w~podrozdziale \ref{sec:wzorzecMVC} wymienione kontrolery muszą zwracać dane w~różnych formatach odpowiednich dla klienta mobilnego (obiekt \emph{JSON}) oraz webowego (dokument \emph{HTML}). Obydwie strony klienckie korzystają z~tego samego interfejsu \emph{REST}, więc wybór zwracanego typu musi być zaimplementowany we wnętrzu kontrolera. Każda ze stron ma możliwość określenia jakiego typu dane chce otrzymać w~nagłówku protokołu \emph{HTTP} o~nazwie \emph{Accept}, który zostanie przeanalizowany wewnątrz metody kontrolera mającej bezpośredni dostęp do żądania otrzymanego przez serwer. Opisane podejście nosi nazwę \emph{Content Negotiation}. Przeglądarka internetowa ma możliwość wyświetlania wielu typów danych i~często ogłasza chęć akceptowania wszystkich przy pomocy wartości \emph{*/*}. W aplikacji mobilnej istnieje możliwość własnej konfiguracji tego nagłówka i~w~tym przypadku ustawiono tylko wartość \emph{application/json}. Kontroler, po wykonaniu logiki, ma więc przygotowany wynik w~postaci danych, które należy zwrócić i jeśli zawartość nagłówka \emph{Accept} zawiera wpis \emph{text/html} (wliczając grupy, takie jak \emph{text/*} czy \emph{*/*}) decyduje się na wysłanie wyrenederowanego na ich podstawie dokumentu \emph{HTML} lub obiektu w formacie \emph{JSON} w przeciwnym wypadku.

\section{Bezpieczeństwo}

%TODO: coś to napisać albo przenieść z któregoś z podrozdziałów

\subsection{Uwierzytelnianie}
\label{sec:uwierzytelnianie}

Uwierzytelnianie jest pojęciem powszechnie rozumianym jako potwierdzenie tożsamości deklarowanej przez podmiot. W~informatyce proces ten wykorzystywany jest kiedy zależy nam na uniemożliwieniu dostępu do danych treści osobom nieupoważnionym, a~więc jest nieodłącznym elementem wszelkich usług (m.in. stron internetowych), przechowujących prywatne dane przeznaczone dla każdego użytkownika z~osobna.

W wypadku aplikacji tworzonej w~ramach pracy, proces uwierzytelniania musi zostać zaimplementowany po stronie serwera Dentaise i~być jednakowo stosowany przez strony klienckie - webową oraz mobilną. Należy więc tak dobrać metodę, aby była możliwa do realizacji na tych dwóch różnych platformach.

\subsubsection{Różne podejścia}

Istnieją różne podejścia pozwalające potwierdzić autentyczność podmiotu, najpopularniejsze z~których zostaną zaprezentowane w~dalszej części tego podrozdziału. Każde z~nich będzie opierać się na podobnym schemacie. 

Pierwszym krokiem jest podanie przez użytkownika pary danych - jego nazwy oraz hasła - a~następnie przesłanie ich i~potwierdzenie zgodności z~danymi przetrzymywanymi w~bazie po stronie serwera. Należy przy tym pamiętać, aby dane te były przechowywane w~sposób nie narażający użytkownika na wyciek ich czytelnej postaci, w~przypadku uzyskania nieautoryzowanego dostępu do bazy przez osoby trzecie. Więcej informacji na ten temat można przeczytać w~podrozdziale \ref{sec:hashowanie}. 

Następnie na podstawie dostarczonych danych, w~wypadku ich pozytywnego rozpatrzenia, nawiązywana jest sesja (podrozdział \ref{sec:sesja}), którą użytkownik identyfikuje się  podczas wysyłania kolejnych żądań do serwera. Identyfikacja przy pomocy sesji jest zautomatyzowana i~ niewidoczna dla użytkownika. Czas trwania sesji zwykle jest ograniczony i~wygasa ona po dłuższym okresie nieaktywności, zmuszając do powtórzenia procesu uwierzytelnienia aby ponownie pozyskać dostęp do treści.

\paragraph{Basic Access Authentication}

Jest to podstawowa metoda uwierzytelniania, gdzie wymagane dane uzupełniane są w specjalnych nagłówkach protokołu HTTP, a więc może być wykorzystywany między innymi przez strony internetowe oraz WebService'y. Uwierzytelnianie tą metodą  przebiega w sposób przedstawiony poniżej. Do lepszego zobrazowania wymiany komunikatów pomiędzy serwerem a klientem (przeglądarką) posłuży przechwycona sesja próby dostępu do menadżera aplikacji na kontenerze Tomcat.

%Użytkownik wysyła żądanie HTTP, przykładowo celem wyświetlenia zawartości strony internetowej, które jak się okazuje podczas jego analizy po stronie serwera dotyczy chronionego zasobu. Serwer zwraca odpowiedź o statusie \emph{401 Unauthorized}, która zawiera w nagłówku \emph{WWW-Authenticate} schemat uwierzytelniania (w tym wypadku \emph{Basic}) oraz nazwę strefy (\emph{realm}), do której należy treść jaką chce pozyskać użytkownik. Zgodnie z \cite{BDA99} nazwa strefy może być dowolna i jest ustalana po stronie serwera. Każdy zasób chroniony pod tą samą strefą (zwracający ten sam \emph{realm} w odpowiedzi \emph{Unauthorized}), musi być dostępny za pomocą tych samych danych uwierzytelniających.

Celem wyświetlenia zawartości strony internetowej, a w tym wypadku menedżera aplikacji znajdującego się na lokalnym kontenerze tomcat użytkownik wprowadza w przeglądarce internetowej adres \emph{http://localhost:8080/manager/html}. Przeglądarka wysyła następujące żądanie.
\begin{lstlisting}
GET /manager/html HTTP/1.1
Host: localhost:8080
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/33.0.1750.152 Chrome/33.0.1750.152 Safari/537.36
Accept-Encoding: gzip,deflate,sdch
Accept-Language: pl-PL,pl;q=0.8,en-US;q=0.6,en;q=0.4
Cookie: JSESSIONID=589E30C58F80986353A1C6A6B9BC02ED
\end{lstlisting}

Jak się okazuje podczas analizy żądania po stronie serwera, dotyczy ono chronionego zasobu. Sposób w jaki określa się, które zasoby są chronione przybliżony został w podrozdziale \ref{sec:ochronaWybranychZasobow}. W tym momencie wystarczy wiedzieć, że w wypadku \emph{Basic Access Authentication}, dzięki temu, że należy do standardu HTTP większość serwerów WWW i kontenerów aplikacji pozwala na wygodną konfigurację poprzez wpisanie adresów URL mających być pokrytymi ochroną, oraz sprecyzowanie listy użytkowników wraz z hasłami dostępu. Ewidentną wadą tego podejścia jest statyczna baza użytkowników\footnote{Niektóre kontenery, na przykład \emph{Tomcat}, pozwalają również na zdefiniowanie połączenia z bazą danych z poziomu pliku konfiguracyjnego, celem uwierzytelniania użytkowników}, nic jednak nie stoi na przeszkodzie, aby utworzyć własną implementację opisywanego schematu po stronie aplikacji webowej.

Serwer zwraca odpowiedź o statusie \emph{401 Unauthorized}, która zawiera w nagłówku \emph{WWW-Authenticate} schemat uwierzytelniania (w tym wypadku \emph{Basic}) oraz nazwę strefy (\emph{realm}), do której należy treść jaką chce pozyskać użytkownik. Zgodnie z \cite{BDA99} nazwa strefy może być dowolna i jest ustalana po stronie serwera. Każdy zasób chroniony pod tą samą strefą (zwracający ten sam \emph{realm} w odpowiedzi \emph{Unauthorized}), musi być dostępny za pomocą tych samych danych uwierzytelniających.
\begin{lstlisting}
HTTP/1.1 401 Unauthorized
Server: Apache-Coyote/1.1
Cache-Control: private
Expires: Thu, 01 Jan 1970 01:00:00 CET
WWW-Authenticate: Basic realm="Tomcat Manager Application"
Content-Type: text/html;charset=ISO-8859-1
Transfer-Encoding: chunked
Date: Tue, 12 Aug 2014 15:58:57 GMT

(... zawartość)
\end{lstlisting}

W odpowiedzi na otrzymany komunikat przeglądarka reaguje wyświetlając okno logowania. Nie jest ono częścią strony do której dostęp chce uzyskać użytkownik, jego obsługa zaimplementowana jest w~całości w~przeglądarce. Kolejną zaletą tej metody jest więc brak konieczności implementacji formularza logowania.

Po wypełnieniu danych użytkownik ponawia próbę żądania, tym razem jednak załączone zostaną dane potwierdzające jego tożsamość w nagłówku \emph{Authenticate}. Wartość nagłówka również zawiera wykorzystywany schemat (\emph{Basic}), ale oprócz tego zakodowaną w~Base64 nazwę użytkownika oraz jego hasło, oddzielone przez dwukropek (\emph{:}). Aby umożliwić stronie serwerowej poprawne oddzielenie danych po ich zdekodowaniu, nazwa użytkownika nie może zawierać tego znaku.
\begin{lstlisting}
GET /manager/html HTTP/1.1
Host: localhost:8080
Connection: keep-alive
Cache-Control: max-age=0
Authorization: Basic dG9tY2F0OnRvbWNhdA==
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/33.0.1750.152 Chrome/33.0.1750.152 Safari/537.36
Accept-Encoding: gzip,deflate,sdch
Accept-Language: pl-PL,pl;q=0.8,en-US;q=0.6,en;q=0.4
Cookie: JSESSIONID=589E30C58F80986353A1C6A6B9BC02ED
\end{lstlisting}

Tym razem klient otrzymuje pozytywną odpowiedź wraz z kodem HTML w~zawartości odpowiedzi, który wyświetli przeglądarka (zawartość została wycięta, gdyż nie jest istotna w~rozpatrywaniu niniejszego procesu).
\begin{lstlisting}
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
Cache-Control: private
Expires: Thu, 01 Jan 1970 01:00:00 CET
Set-Cookie: JSESSIONID=3EE8A15F1F9714D7E390F9F1E36FC8F7; Path=/manager/; HttpOnly
Content-Type: text/html;charset=utf-8
Transfer-Encoding: chunked
Date: Tue, 12 Aug 2014 15:59:02 GMT

(... zawartość)
\end{lstlisting}

Kolejne żądania do tej samej strefy nie wymagają ponownego wypełnienia formularza, ponieważ dane zostają zapamiętane w przeglądarce i~są załączane automatycznie. Użytkownik nie musi dbać o ponowne podawanie swoich danych na czas trwania sesji. Niestety standard ten nie pozwala w prosty sposób obsłużyć opcji wylogowania się (zakończenia sesji przed czasem).

Warto zauważyć, że dane przesyłane są w niezaszyfrowanej postaci (\emph{clear text}), więc mogą zostać przywrócone do swojej oryginalnej formy, jaką podaje w oknie logowania użytkownik, po zdekodowaniu zawartości nagłówka \emph{Authorization} przy pomocy tego samego algorytmu, który został użyty do ich zakodowania czyli \emph{Base64}. \emph{Basic access authentication} dla zapewnienia bezpieczeństwa wymaga zastosowania dodatkowego protokołu szyfrującego, ponieważ dane uwierzytelniające mogą zostać odczytane przez każdą osobę mogącą przechwycić pakiet z wysyłanym żądaniem. Zwykle w tym celu stosuje się szyfrowaną wersję protokołu \emph{HTTP} czyli \emph{HTTPS}.

\paragraph{Digest Access Authentication}
%TODO? w razie potrzeby będzie można uzupełnić o dokładny sposób tworzenia skrótu

Ze względu na to, że w schemacie \emph{Basic Access Authentication} dane uwierzytelniające użytkownika są przesyłane w postaci niezaszyfrowanej, nie można go uznać za bezpieczny jeśli nie skorzysta się z dodatkowej warstwy zapewniającej szyfrowanie komunikacji. \emph{Digest Access Authentication} jest jego usprawnieniem pod kątem bezpieczeństwa przesyłanych danych.

Schemat komunikacji wygląda podobnie jak w poprzednim wypadku. Do prześledzenia wymiany komunikatów pomocny będzie przykład z~\cite{BDA99}.

Pierwsze żądanie nie różni się niczym od zawartego w przykładzie z \emph{Basic Access Authentication} poza zmianą zasobu, który chcemy uzyskać. W tym wypadku serwer również odsyła odpowiedź \emph{401 Unauthorized}, jednak zawiera ona znacznie więcej danych.

Oprócz parametru \emph{realm} omówionego wcześniej, w~odpowiedzi zwrotnej mogą znaleźć się następujące pola:
\begin{description}
\item[domain] \hfill \\
Lista adresów przypadających pod strefę określoną w~\emph{realm}. Te same dane uwierzytelniające powinny pozwolić klientowi uzyskać dostęp do wszystkich wymienionych w~tym polu zasobów.
\item[nonce] \hfill \\
%TODO? nonce jest ogólnym pojęciem, można o nim coś więcej napisać...
Wartość ustalana przez serwer. Jest użyta jako unikalny fragment hashowanych ciągów, aby uniemożliwić przeprowadzenie ataku przez powtórzenie. W~tym celu serwer powinien zwracać unikalną wartość dla każdej odpowiedzi \emph{401 Unauthorized}. Zwykle jest ciągiem znaków zakodowanym w Base64 lub zapisanym w systemie heksadecymalnym, który zawiera w~sobie między innymi aktualny czas, aby umożliwić sprawdzenie, czy odpowiedź klienta nie przyszła po zbyt długim czasie.
\item[opaque] \hfill \\
Ciąg znaków ustalany przez serwer, który powinien być zwrócony w niezmienionej postaci przez klienta. Może zostać użyty do przesyłania dodatkowych informacji, na przykład kiedy za uwierzytelnianie odpowiada serwer inny niż hostujący zasób, do którego klient chce uzyskać dostęp. W~tym celu można jednak również wykorzystać pole \emph{nonce}.
%TODO? hash? z ang. hash?
\item[stale] \hfill \\
Flaga ustawiana na \emph{TRUE} jeżeli otrzymane żądanie zawierało przeterminowany \emph{nonce}, ale dane uwierzytelniające wraz z~nim tworzą poprawny skrót\footnote{Wynik funkcji skrótu (hash)}. Umożliwia to powtórzenie żądania z nowym \emph{nonce}, bez ponownego angażowania użytkownika końcowego w podawanie loginu i~hasła.
\item[algorithm] 
\hfill \\Wybrany algorytm funkcji skrótu (domyślnie \emph{MD5}).
\item[qop] \hfill \\
Pole opcjonalne (\emph{quality of protection}). W~celu zapewnienia kompatybilności wstecznej może zostać pominięte. W~zależności od wyboru skrót będzie komponowany na podstawie innego zestawu danych. Dozwolone wartości to \emph{auth} i~\emph{auth-int}, spośród których serwer może wysłać dowolną kombinację. Na podstawie zwróconych możliwości strona kliencka będzie mogła dokonać wyboru odsyłając jedną z~nich lub całkowicie je pomijając. Jeżeli jednak odpowiedź serwera zawiera to pole, zaleca się, aby klient również je uwzględnił.
\item[auth-param] \hfill \\
Pole służące do przyszłych rozszerzeń.
\end{description}

Przykładowa odpowiedź serwera będzie wyglądać następująco.
\begin{lstlisting}
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Digest
realm="testrealm@host.com",
qop="auth,auth-int",
nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
opaque="5ccc069c403ebaf9f0171e9517f40e41"
\end{lstlisting}

Podobnie jak w~przykładzie dotyczącym \emph{Basic Access Authentication} klient musi na nie odpowiedzieć, umieszczając dane uwierzytelniające w nagłówku \emph{Authenticate}. Użytkownikowi wyświetli się okno logowania obsługiwane przez przeglądarkę, gdzie może podać swój login i~hasło, a~następnie dane te zostaną przetworzone, dając w~wyniku nagłówek, który zostanie przesłany w~powtórzonym żądaniu do serwera.
\begin{lstlisting}
Authorization: Digest username="Mufasa",
realm="testrealm@host.com",
nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
uri="/dir/index.html",
qop=auth,
nc=00000001,
cnonce="0a4f113b",
response="6629fae49393a05397450978507c4ef1",
opaque="5ccc069c403ebaf9f0171e9517f40e41"
\end{lstlisting}

\begin{description}
\item[username] \hfill \\
Nazwa użytkownika w czystej postaci.
\item[realm] \hfill \\
Nazwa strefy przesłana przez serwer wraz z~odpowiedzią \emph{401 Unauthorized}.
\item[nonce] \hfill \\
Unikalna wartość przesłana przez serwer wraz z~odpowiedzią \emph{401 Unauthorized}.
\item[uri] \hfill \\
URI zasobu, który chce uzyskać klient. Ta sama wartość (\emph{Request-URI})znajduje się w pierwszej linijce żądania (\emph{Request-Line}), ale jest duplikowana ponieważ może zostać zmieniona przez serwery pośredniczące.
\item[qop] \hfill \\
Wartość pola jest wybierana na podstawie możliwości oferowanych przez serwer w~tym samym polu. Tym razem jednak odsyłana jest pojedyncza wartość, na którą ostatecznie zdecydowała się strona kliencka. Pole jest opcjonalne, ale powinno zostać załączone do żądania jeśli serwer również zwrócił je w~odpowiedzi.
\item[nc] \hfill \\
Liczba żądań (łącznie z~tym), które zostały dotychczas wysłane z załączoną wartością \emph{nonce} (\emph{nonce count}). Umożliwia to sprawdzenie powtórzeń żądań poprzez trzymanie ich własnego licznika po stronie serwera i porównywanie go z~tą wartością.
\item[cnonce] \hfill \\
Wartość ustalana przez stronę kliencką, która również może być wykorzystywana do obliczenia finalnego skrótu. Ma to zapobiec atakom typu \emph{Man In The Middle}, który mógłby mieć miejsce jeśli osoba przechwytująca transmisję miała by pełną kontrolę nad sposobem tworzenia skrótów. Atakujący mógłby preparować wartość \emph{nonce} w~taki sposób, aby za każdym razem była taka sama. Dzięki temu będzie można zebrać duży zbiór skrótów od użytkowników gdzie niewiadoma jest zawsze tylko jedna - ich hasła. Wykorzystując ten fakt atakujący może przygotować tablice tęczowe ze skrótami zbudowanymi na spreparowanej wartości \emph{nonce}, co znacznie ułatwi zadanie znalezienia hasła użytkownika. Dodanie dodatkowej niewiadomej, która tym razem pochodzi od użytkownika zabezpiecza przed opisaną sytuacją, znacznie zwiększając nakład obliczeń potrzebny do odgadnięcia wielu haseł z bazy użytkowników atakowanej usługi.
\item[response] \hfill \\
Finalny skrót, będący dowodem autentyczności użytkownika. W~zależności od wybranego \emph{qop} oraz algorytmu może zawierać w~sobie pola \emph{nonce}, \emph{nc}, \emph{cnonce}, \emph{qop}, \emph{username}, \emph{realm} oraz hasło użytkownika. Zawarcie tych pól w ciągu znaków poddanemu operacji funkcji skrótu uniemożliwia prostą podmianę tych wartości w~ich oryginalnych polach przez atakującego.
\item[opaque] \hfill \\
Ciąg znaków zwrócony przez serwer wraz z~odpowiedzią \emph{401 Unauthorized}.
\end{description}

Serwer otrzymując ponowne żądanie, tym razem zawierające dane uwierzytelniające próbuje samodzielnie utworzyć skrót korzystając z~tych samych algorytmów i~zasad, na jakich powstawała wartość przekazywana w~polu \emph{response}. Do obliczeń wykorzystuje się pola przesłane z~powrotem od klienta, oraz jego hasło odczytane z~zewnętrznego źródła (np. bazy danych), więc nie jest wymagane trzymanie stanu tego procesu po stronie serwerowej.

Ponieważ większość informacji jest pozyskiwanych od klienta konieczne jest zabezpieczenie się przed ewentualną podmianą tych wartości, zamieszczając je również w skrócie. W~przeciwnym wypadku atakujący mógłby podsłuchać wymianę komunikatów między prawdziwym użytkownikiem, a~serwerem oraz wyciągnąć z~niego skrót znajdujący się w polu \emph{response}, a~następnie podmieniając inne pola komponować własne zapytania. Zmieniając wartość URI żądania mógłby uzyskiwać dostęp do innych zasobów należących do oryginalnego właściciela przechwyconej sesji. Wynik porównania przesłanego i~uzyskanego wyniku jest ostatecznym dowodem autentyczności użytkownika.

Należy podkreślić, że schemat \emph{Digest Access Authentication} utajnia jedynie przesyłane hasło użytkownika. Komunikacja nie jest szyfrowana, więc zawsze istnieje ryzyko przechwycenia pakietów oraz przeglądanie zawartości odpowiedzi HTTP zawierającej treść, która ma zostać wyświetlona uwierzytelnionemu użytkownikowi. W~razie chęci zabezpieczenia się przed tym, należy skorzystać z szyfrowanego protokołu \emph{HTTPS}.

Niestety podobnie jak jego poprzednik, \emph{Digest Access Authentication} nie pozwala na obsłużenie akcji wylogowania.

\paragraph{Form-based authentication}

Ostatnim omawianym spośród najpopularniejszych schematów uwierzytelniania jest \emph{Form-based authentication}. Protokół \emph{HTTP} w tym wypadku nie bierze bezpośredniego udziału w~uwierzytelnianiu użytkownika. Dane autoryzacji nie są przesyłane za pomocą nagłówków, a w~treści jego żądania. Z~tego wynika, że samodzielnie należy obsłużyć całość procesu.

Kolejnym założeniem jest to, że całość danych przesyłanych jest w~czystej postaci. Hasła nie są przetwarzane przez funkcje skrótu na etapie komunikacji, a~więc konieczne jest skorzystanie z~innego sposobu zabezpieczenia tych danych przed dostępem osób trzecich. Najczęściej oczywiście wykorzystuje się w~tym celu protokół \emph{HTTPS}.

Przez zastosowanie szyfrowania komunikacji mamy zapewnioną ochronę nie tylko wrażliwych danych klienta, to znaczy jego prywatnego hasła, ale również innych treści takich jak dane pacjenta, które byłyby przesyłane np. podczas edycji, lub pobieraniu listy pacjentów. Wśród tych danych znajdują się zwykle numery PESEL, adresy e-mail, czy telefon kontaktowy i~niedopuszczalne jest umożliwienie dostępu do nich osobom niepowołanym.

Ze względu na to, że metoda \emph{Form-based authentication} nie korzysta z żadnych standardów, przeglądarka nie ma możliwości automatycznie obsłużyć procesu logowania, wobec czego konieczna jest samodzielna implementacja widoku dla tego procesu. Zwykle używa się w tym celu formularzy \emph{<FORM>} języka \emph{HTML}, których zawartość przesyłana jest do serwera metodą \emph{POST} protokołu \emph{HTTP}. W tym wypadku konieczność utworzenia własnego widoku logowania nie jest przeszkodą, ponieważ warto zapewnić spójny interfejs graficzny, z~którym użytkownik powinien mieć styczność już na etapie logowania. W przypadku \emph{Basic Access Authentication} oraz \emph{Digest Access Authentication} użytkownikowi zaprezentowane zostanie zaimplementowane w przeglądarce okno dialogowe na tle pustej strony. Przejmując kontrolę nad tym procesem, już na etapie pobierania danych mamy możliwość wyświetlić logo i~nazwę produktu oraz obsłużyć błędy logowania wyświetlając przydatne informacje.

W~implementacji obsługi logowania metodą \emph{Form-based authentication}, podobnie jak w~innych omawianych schematach należy zadbać o~to, aby chronione były nie tylko zasoby odpowiadające wyświetlanym treściom (tzn. adresy URL stron i~podstron, po których porusza się użytkownik), ale również cała komunikacja mająca miejsce w~tle, na przykład wywołania metod \emph{WebService'u} przy pomocy zapytań \emph{AJAX}. Odpowiedzialność tą najlepiej jest przerzucić na instancje znajdujące się na wyższym poziomie abstrakcji, tak jak w wypadku \emph{Basic Access Authentication} oraz \emph{Digest Access Authentication} mógł zajmować się tym serwer WWW lub kontener aplikacji, poprzez zdefiniowanie chronionych adresów URL w~pliku konfiguracyjnym. Pozwoli to na uniknięcie konieczności pamiętania o ręcznym wywołaniu procesu sprawdzenia czy użytkownik został uwierzytelniony dla każdej operacji z~osobna, przed zwróceniem potencjalnie wrażliwych danych. O~tym jak tego dokonać, przeczytać można w podrozdziale \ref{sec:ochronaWybranychZasobow}.

Scenariusz użytkowania usługi zaczyna się operacją logowania niezależnie od tego czy użytkownik wprowadza URL prowadzący bezpośrednio do formularza pozwalającego na uwierzytelnienie się, czy próbuje wejść w~zasób chroniony. Należy przy tym podkreślić, że ekran logowania nie jest z~oczywistych względów w~żaden sposób chroniony - musi być dostępny dla każdego użytkownika chcącego zalogować się w~usłudze. W~przypadku gdy niezalogowany użytkownik próbuje dostać się do chronionego zasobu, zostaje on automatycznie przekierowany do ekranu logowania. W~przeciwieństwie do poprzednio omawianych metod uwierzytelniania, w~takim wypadku nie trzeba zwracać komunikatu \emph{401 Unauthorized}, a~wystarczy wysłać przekierowanie w postaci odpowiedzi \emph{303 See Other}, który zostanie automatycznie obsłużony przez przeglądarkę kierując użytkownika do podstrony logowania.

Po wypełnieniu danych w~formularzu wysyłane jest zapytanie \emph{POST} pod adres operacji uwierzytelniania. Jeśli dane przekazane przez użytkownika są poprawne, rozpoczynana jest sesja, której identyfikatorem od tej pory posługuje się użytkownik jako jedyną wartością potrzebną do udowodnienia swojej tożsamości. Klucz sesji przechowywany jest w~plikach \emph{Cookies} po stronie klienta oraz załączany jest do każdego kolejnego żądania.

Sesja ma ograniczony czas trwania, ale może również zostać przedwcześnie przeterminowana poprzez wylogowanie. W przeciwieństwie do metod \emph{Basic Access Authentication} oraz \emph{Digest Access Authentication} mając pełną kontrolę nad procesem uwierzytelniania, można tego łatwo dokonać udostępniając operację unieważniającą klucz sesji wywołującego ją użytkownika.

Więcej o~sposobach tworzenia i~zarządzania sesją można przeczytać w podrozdziale \ref{sec:sesja}.

\subsubsection{Wybór metody}

Niezmiernie ważnym aspektem dla wyboru odpowiedniego schematu uwierzytelniania jest uchronienie nie tylko wrażliwych danych użytkownika ale i~pacjenta. \emph{Basic Access Authentication} oraz \emph{Form-based Authentication} nie zapewniają same w sobie ochrony dla żadnego z~nich, podczas gdy \emph{Digest Access Authentication} chroni hasło użytkownika, pozostawiając jednak inne treści w~czystej postaci. Konieczne jest zatem, niezależnie od wyboru, wprowadzenie szyfrowania całej komunikacji pomiędzy klientem a~serwerem przy pomocy protokołu \emph{HTTPS}. W~takim wypadku korzyść zastosowania \emph{Digest Access Authentication} w miejsce \emph{Basic Access Authentication} jest niewielka, ponieważ dane użytkownika będą bezpieczne niezależnie od wyboru. Prostota \emph{Basic Access Authentication} przemawia na jej korzyść, jednak niesie ze sobą wiele ograniczeń takich jak brak możliwości wylogowania oraz implementacji własnego interfejsu logowania.

\emph{Form-based Authentication} wymaga więcej pracy ze względu na konieczność implementacji obsługi sesji, jednak w aplikacjach tego typu jest najlepszym wyborem dla osiągnięcia pełnej kontroli nad procesem uwierzytelniania i~na tą metodę zdecydowano się w~ramach tworzonej aplikacji.

\subsubsection{Hashowanie}
\label{sec:hashowanie}

W przypadku wycieku bazy zawierającej hasła użytkownika, ich bezpieczeństwo jest zagrożone nie tylko w~obrębie usługi, na której przeprowadzono atak, ale też innych serwisów, w~których są oni zarejestrowani. Jest to spowodowane bardzo częstą, ale błędną praktyką stosowania tych samych haseł dostępu dla różnych usług przez jedną osobę. Atakujący w~przedstawionym przypadku ma zwykle dostęp do haseł oraz innych danych użytkownika, na przykład adresów e-mail, z~których może skorzystać, aby odnaleźć inne serwisy, gdzie zarejestrowana dana osoba i~dokonać próby włamania. Atak na mało znaczącą dla użytkownika usługę, gdzie bezpieczeństwo może być znacznie obniżone, taką jak forum dyskusyjne czy portal informacyjny, może doprowadzić do przejęcia kontroli nad najistotniejszymi systemami, na przykład pocztą elektroniczną. Niezmiernie ważne jest więc, aby bez względu na wrażliwość przechowywanych danych zapewnić swoim użytkownikom odpowiednie bezpieczeństwo.

Podstawową metodą obrony przed wyciekiem haseł jest przechowywanie ich postaci innej niż dostarczają użytkownicy, do czego służą funkcje skrótu. Ich wynikiem jest skrót, zwany również hashem, który ze względu na jednokierunkowość tej operacji nie pozwala na odzyskanie argumentu wejściowego, jakim jest oryginalne hasło.

Istnieją różne rodzaje funkcji skrótu i~nie wszystkie z~nich nadają się do bezpiecznego przechowywania haseł. Niezależnie od długości argumentu, przy tej samej konfiguracji wynik będzie miał jednakową długość, a~każda najmniejsza zmiana w~parametrze wejściowym skutkuje w całkowicie innej przyporządkowanej wartości wynikowej, co obrazuje przykład z wykorzystaniem algorytmu \emph{MD5}.

\begin{lstlisting}
md5("dentaise to aplikacja wspomagająca zarządzanie gabinetem dentystycznym") = 0e100aacf0fe1b20d5cb152bef556626
md5("dentaisf to aplikacja wspomagająca zarządzanie gabinetem dentystycznym") = a572a0958932537c0aa42c5599021491
\end{lstlisting}

Ze względu na ten charakter funkcje skrótu często wykorzystywane są również do sprawdzania integralności danych. W~takim wypadku kluczowe jest nie bezpieczeństwo, a~szybkość operacji.

W~\cite{CSH} wyróżnione zostały następujące ataki mające na celu złamanie skrótu:
\begin{description}
\item[Dictionary] \hfill \\
Atak słownikowy polegający na generowaniu skrótów bazując na zbiorze popularnych haseł stosowanych przez użytkowników, do momentu znalezienia zgodności ze sprawdzanym skrótem.
\item[Brute Force] \hfill \\
Atak polegający na sprawdzaniu wszystkich możliwości, na przykład: aaaaaa, aaaaab, aaaaac...
\item[Lookup Tables] \hfill \\
Metoda umożliwiająca łamanie wielu hashy równolegle poprzez wcześniejsze przygotowanie dużego zbioru skrótów i~haseł, na podstawie których zostały wygenerowane. W~odróżnieniu od ataku słownikowego metoda ta nie wymaga już obliczania skrótu dla każdego sprawdzanego hasła, co sprawia że jest znacznie szybsza.
\item[Reverse Lookup Tables] \hfill \\
Połączenie podejść \emph{Lookup Table} i~ataku słownikowego lub metody \emph{Brute Force}, gdzie najpierw dla wszystkich skrótów znajdujących się w~wykradzionej bazie danych przyporządkowuje się użytkowników, którym był przypisany. Następnie oblicza się skrót dla każdego zgadywanego hasła metodą słownikową lub sprawdzając wszystkie kolejne możliwości i~sprawdza się którzy użytkownicy mieli uzyskany hash. Metoda ta wykorzystuje fakt, że często wielu użytkowników korzysta z~tego samego hasła.
%TODO? doczytać http://kestas.kuliukas.com/RainbowTables/
\item[Rainbow Tables] \hfill \\
Usprawnienie metody \emph{Lookup Table}, która ze względu na konieczność przechowywania wszystkich skrótów zajmuje bardzo dużą część przestrzeni dyskowej. Zastosowanie tablic tęczowych pozwala na przechowywanie większej bazy, kosztem czasu potrzebnego na złamanie hasła. Modyfikacja polega na wprowadzeniu funkcji redukującej, która przyporządkowuje skrótom ciągi znaków kwalifikujące się jako hasła. Należy podkreślić, że nie jest to operacja odwracająca operację funkcji skrótu, tzn. wynik redukcji nie jest hasłem na podstawie którego otrzymano skrót, będący wejściem dla tej funkcji. Metoda polega na tworzeniu łańcuchów $plaintext \rightarrow hash \rightarrow plaintext \rightarrow hash \rightarrow \ldots \rightarrow plaintext \rightarrow hash$, gdzie przetrzymywane są jedynie początkowe i~końcowe wartości oraz przechodzeniu po nich celem odnalezienia skrótu wejściowego. Szukane hasło jest wartością poprzedzającą. Dokładniejsze wyjaśnienie działania tablic tęczowych można przeczytać w~\cite{RT}.
\end{description}

Ataki słownikowe oraz metodą \emph{Brute Force} są najprostszymi sposobami łamania skrótów, ale zarazem bardzo mało wydajnymi czasowo. Wszelkie działania im zapobiegające, jedynie przedłużają czas potrzebny na złamanie skrótu, który jednak jest i~tak na tyle długi, że w~przypadku kombinacji bezpiecznej funkcji i~silnego hasła zagrożenie płynące z~zastosowania tych technik jest nikłe.

Kuszące może być podejście obliczania skrótu już po stronie klienta i~przesyłanie tej gotowej postaci do sprawdzenia z~bazą danych po stronie serwera, dzięki czemu hasło nie jest przekazywane w~czystej postaci, co może zostać wykorzystane poprzez podsłuchanie transmisji. Nie jest to zalecane, ponieważ w~przypadku wycieku listy skrótów istnieje możliwość włamania się na konto danego użytkownika bez znajomości jego hasła. Z tego względu operacja ta powinna być wykonywana bezwzględnie po stronie serwera, a~opisany schemat może być jedynie dodatkowym zabezpieczeniem.

W~odróżnieniu od innych zastosowań funkcji skrótów, w bezpieczeństwie szybkość operacji nie jest cechą pożądaną. Wydłużając czas potrzebny do policzenia skrótu, znacznie utrudnia się przeprowadzanie ataku, zwłaszcza przy wykorzystaniu tych dwóch prostych technik. Ze względu na to iż dokonuje się w~nich obliczeń na bieżąco dla każdego zgadywanego hasła, potrzeba znacznie więcej czasu na odnalezienie pasującego ciągu znaków, nawet przy minimalnym zmniejszeniu szybkości pojedynczej operacji.

Funkcje skrótu przyporządkowują dane o~dowolnej długości do wartości wynikowej o~stałym rozmiarze, więc może się zdarzyć, że dwa różne ciągi znaków odpowiadają temu samemu skrótowi. Zdarzenie to nazywa się kolizją i~jest niepożądane, kiedy stosuje się je w~celach bezpieczeństwa. Funkcje skrótu znacznie minimalizujące tę cechę nazywa się kryptograficznymi funkcjami skrótu. W~\cite{CSH} zaleca się stosowanie następujących algorytmów:

\begin{itemize}
\item SHA256
\item SHA512
\item RipeMD
\item WHIRLPOOL
\item SHA3
\item PBKDF2
\item bcrypt
\item scrypt		
\end{itemize}

Bardzo popularny niegdyś algorytm MD5 od roku 2004 nie można zaliczyć do bezpiecznych, kiedy to ostatecznie udowodniono, że na danych wejściowych składających się z~512 bitowych bloków da się utworzyć dwie podobne wiadomości o~tym samym skrócie. Więcej na temat tej demonstracji można przeczytać w \cite{Md5C06}.

Według \cite{RIG} największe zagrożenie płynie z~zastosowania tanich układów GPU\footnote{Graphics Processing Unit}, FPGA\footnote{Field Programmable Gate Array} lub ASIC\footnote{Application-specific Integrated Circuit}. Wykorzystując ich równoległość atakujący może próbować łamać wiele haseł jednocześnie. Algorytm wymagający dużo zasobów w~postaci stosunkowo kosztownej pamięci oraz uniemożliwiający znaczny wzrost szybkości poprzez wykorzystanie wielu rdzeni pozwala na obniżenie ich skuteczności. 

\paragraph{Sól}
\label{sec:sol}

Metody \emph{Lookup Table} oraz \emph{Rainbow Table} wykorzystują przygotowane tablice skrótów dla zdefiniowanego zbioru haseł, więc mogą dokonywać wyszukiwania w~niezwykle szybki sposób. Zastosowanie silnego algorytmu funkcji skrótu nie będzie w~tym wypadku wystarczające, ponieważ w~czasie ataku wykona się stosunkowo mało (lub wcale) operacji tego typu.

Najlepszym zabezpieczeniem przed tego typu metodami jest uniemożliwienie przygotowania tablic skrótów dla znanych algorytmów i haseł poprzez wprowadzenie losowego elementu do przetrzymywanych w bazie danych wartości. Aby atak był skuteczny, przygotowane tablice musiałyby uwzględniać ten element, który dla każdego hasła jest inny, co sprawia że przygotowanie tak dużej bazy staje się niepraktyczne. Element ten nazywany jest solą.

Sól (\emph{salt}) jest losowym ciągiem znaków o~określonej długości, dołączany przed, lub za hasłem (\emph{password}) zanim dokona się operacji skrótu (\emph{hash()}). Dzięki temu podejściu nawet użytkownicy korzystający z~tego samego hasła, niezależnie od tego czy zarejestrowani są w~tej samej czy innej usłudze, mają przypisany zupełnie inny skrót (\emph{H}). Operację obrazuje poniższy wzór.

$H = hash(salt + password)$

Częstym błędem jest stosowanie tej samej soli dla w obrębie jednej implementowanej usługi. Takie podejście jest mało skutecznie, ponieważ naraża na przygotowanie tablic tęczowych lub \emph{Lookup Tables} specjalnie pod tą wartość. Trzeba również pamiętać o~tym, aby wygenerować nową wartość soli za każdym razem, gdy użytkownik zmienia swoje hasło.

Ważną cechą zarówno funkcji skrótu jak i~soli jest ich nieprzewidywalność. Należy zatem pamiętać, aby wygenerowane wartości wynikały z~użycia kryptograficznie bezpiecznych generatorów liczb pseudolosowych (\emph{CSPRNG}), o~których wspomniano również w~podrozdziale \ref{sec:identyfikator}.

\paragraph{Przykład}

W~implementowanej aplikacji do bezpiecznego przechowywania skrótów haseł zdecydowano się na wykorzystanie algorytmu \emph{PBKDF2}. Poniższy listing przedstawia klasę realizującą zadanie przekształcania haseł do skrótów z~wykorzystaniem soli.

\begin{lstlisting}[language=Java]
package controllers;

import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;

public class PasswordHashing {
	private static final int SALT_LENGTH = 16; //16 bytes = 128 bits
	private static final int ITERATIONS = 1000;
	private static final int KEYLENGTH = 128;

	public static String hash(String password, String salt) {
		try {
			PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt.getBytes("UTF-8"), ITERATIONS, KEYLENGTH);
			SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1");
			byte hash[] = factory.generateSecret(keySpec).getEncoded();
			return toHex(hash);
		} catch (UnsupportedEncodingException e) {
			throw new RuntimeException(e);
		} catch (InvalidKeySpecException e) {
			throw new RuntimeException(e);
		} catch (NoSuchAlgorithmException e) {
			throw new RuntimeException(e);
		}
	}

	public static String generateSalt() {
		try {
			SecureRandom secureRandom;
			secureRandom = SecureRandom.getInstance("SHA1PRNG");
			byte[] salt = new byte[SALT_LENGTH];
			secureRandom.nextBytes(salt);
			return toHex(salt);
		} catch (NoSuchAlgorithmException e) {
			throw new RuntimeException(e);
		}
	}
	
	private static String toHex(byte[] array) {
		BigInteger bigInteger = new BigInteger(1, array);
		return bigInteger.toString(16);
	}
	
}
\end{lstlisting}

%TODO? długość klucza

\subsubsection{Sesja}
\label{sec:sesja}

Sesja służy do identyfikacji użytkownika łączącego się z~usługą po etapie logowania oraz pozwala na wymuszenie ponownego uwierzytelnienia się po upłynięciu zbyt długiego czasu od ostatniego otrzymanego żądania. Dodatkową zaletą jest wzrost wydajności, poprzez brak konieczności wywoływania kosztownej operacji funkcji skrótu na haśle użytkownika, które w~przeciwnym wypadku dołączane by było do każdego żądania.

\paragraph{Cookies}
\label{sec:cookies}

Po zalogowaniu klient musi automatycznie wysyłać wszystkie żądania wraz z~przydzielonym mu identyfikatorem sesji. Ze względu na to, iż protokół \emph{HTTP} jest bezstanowy, wykorzystuje się w~tym celu \emph{Cookies} (ciasteczka). Jak można przeczytać w~\cite{MsC} służą one do przechowywania ogólnego zbioru  informacji dotyczących klienta, takich jak zawartość jego koszyka (w wypadku serwisu realizującego funkcjonalność sklepu internetowego), ustawień dotyczących odwiedzanej witryny, czy jego stanu. Dla przykładu klient może zmienić preferencje widoku strony internetowej, takie jak kolor tła. Dane te są początkowo przesyłane w~zapytaniu \emph{HTTP} do serwera, na przykład przy pomocy formularza \emph{HTML} i~metody \emph{POST}. Po stronie serwera następuje ich analiza i~tłumaczenie na polecenia ustawiające je jako ciasteczka na maszynie klienta. W~kolejnych zapytaniach ustawienia te są dołączane do wszystkich żądań, dzięki czemu strona wyświetla się zawsze w~kolorze wybranym przez użytkownika.

Zgodnie z~\cite{RfcC11}, zarządzanie \emph{Cookies} odbywa się przy pomocy dwóch nagłówków protokołu \emph{HTTP}:
\begin{description}
\item[Nagłówek Set-Cookie] \hfill \\
Nagłówek używany do przesyłania ustawień ciasteczek od serwera do klienta w~odpowiedzi na jego zapytanie. Przykładowy format widoczny jest poniżej.
\begin{lstlisting}
Set-Cookie: SID=31d4d96e407aad42
\end{lstlisting}
Tak przygotowany nagłówek \emph{Set-Cookie} spowoduje ustawienie ciasteczka o~nazwie \emph{SID} (\emph{Session ID}, czyli identyfikator sesji) i~wartości \emph{31d4d96e407aad42}. Dodatkowo istnieje możliwość definiowania różnorodnych atrybutów oddzielając je znakiem średnika:
\begin{description}
\item[Path] \hfill \\
Atrybut, który definiuje pulę zasobów, do których może zostać wysłane ciasteczko. Pod uwagę brane są również zasoby zagnieżdżone.
\item[Expires] \hfill \\
Określa maksymalną żywotność ciasteczka. Klient nie ma obowiązku przetrzymywania go, aż do określonej w~wartości daty i~czasu - ciasteczko może zostać usunięte wcześniej.
\item[Max-Age] \hfill \\
Podobnie jak \emph{Expires} określa maksymalny czas życia ciasteczka, ale definiowany jest jako liczba sekund do czasu wygaśnięcia. Jeśli obydwa atrybuty \emph{Expires} i~\emph{Max-Age} występują w~jednej odpowiedzi \emph{HTTP}, priorytet ma \emph{Max-Age}.
\item[Domain] \hfill \\
Atrybut służący do określenia zakresu nazw domen, do których wysyłane może być ciasteczko. W~przypadku jego pominięcia ciasteczka będą kierowane tylko do serwera, z~którego pochodzi odpowiedź.
\item[Secure] \hfill \\
Flaga oznaczająca, że ciasteczko może zostać wysłane tylko przez bezpieczny kanał komunikacji (\emph{HTTPS}). W~przypadku transmisji HTTP przy pomocy przeglądarki wspierającej flagę \emph{Secure} zostanie ono pominięte. Więcej na temat konfiguracji tej flagi na różnych serwerach można przeczytać w~\cite{SecF}.
\item[HttpOnly] \hfill \\
Flaga, zawężająca dostęp do ciasteczka. W~szczególności uniemożliwia jego odczyt z~poziomu skryptów znajdujących się po stronie klienta, na przykład JavaScript, co mogłoby doprowadzić do wykradnięcia identyfikatora sesji przy pomocy ataku \emph{Cross-site Scripting}. Jak można przeczytać w~\cite{HtOn} funkcjonalność ta jest implementowana po stronie przeglądarek internetowych. Jeżeli zostanie wykryta próba dostępu do ciasteczka oznaczonego flagą \emph{HttpOnly}, zamiast poprawnej wartości zwrócony zostanie pusty ciąg znaków. 
\end{description}
Odpowiedź \emph{HTTP} może konfigurować wiele takich ciasteczek, zawierając je w~osobnych nagłówkach, na przykład:
\begin{lstlisting}
Set-Cookie: SID=31d4d96e407aad42; Path=/; Secure; HttpOnly
Set-Cookie: lang=en-US; Path=/; Domain=example.com
\end{lstlisting}
\item[Nagłówek Cookie] \hfill \\
Wszystkie ciasteczka, które mogą zostać wysłane do serwera, z~którym komunikuje się klient zostaną zamieszczone w~tym nagłówku. Poszczególne pary nazw i~wartości oddzielone są średnikami. Żądanie \emph{HTTP} może zawierać tylko jeden nagłówek \emph{Cookie}. Poniższy listing zawiera przykład nagłówka zawierającego dwa ciasteczka, z~przykładu zamieszczonego w~omówieniu \emph{Set-Cookie}: \emph{SID} oraz \emph{lang}.
\begin{lstlisting}
Cookie: SID=31d4d96e407aad42; lang=en-US
\end{lstlisting}
\end{description}

Użycie atrybutu \emph{Expires} nagłówka \emph{Set-Cookie} dodatkowo definiuje sposób w~jaki ciasteczka będą przechowywane na maszynie klienta. \cite{MsC} specyfikuje dwa rodzaje \emph{Cookies}:

\begin{description}
\item[Trwałe] \hfill \\
Ten typ ciasteczek zostanie zastosowany jeśli w~nagłówku \emph{Set-Cookie} zdefiniowany jest atrybut \emph{Expires}. W~takim wypadku ciasteczka przechowywane są w~plikach na dysku maszyny klienta, maksymalnie do określonego w~nim czasu. Stan jest zachowany pomiędzy różnymi sesjami klienta (czyli po zrestartowaniu przeglądarki internetowej).
\item[Przechowywane w pamięci] \hfill \\
Ciasteczka są przechowywane w pamięci jedynie na czas trwania sesji klienta. Po wyłączeniu przeglądarki znikną.
\end{description}

Warto zauważyć, że w~powyższym opisie ``sesja klienta'' nie odnosi się do sesji nawiązywanej pomiędzy klientem a~serwerem, która jest głównym tematem tego podrozdziału. W tym szczególnym wypadku jest to sesja użytkowania klienta \emph{HTTP} jakim jest przeglądarka internetowa.

\paragraph{Sesja po stronie klienta lub serwera}

Pierwszym problemem z~jakim należy się zmierzyć, jest wybór miejsca przechowywania stanu sesji. 

Jednym z~podejść jest trzymanie wszelkich informacji związanych z sesją użytkownika w bazie danych po stronie serwera. Identyfikatorem sesji jest wtedy losowy ciąg znaków o~określonej długości, który może posłużyć również jako klucz główny tablicy. Wszelkie inne informacje takie jak czas wygaśnięcia, czy nazwa zalogowanego użytkownika mogą być dodatkowymi kolumnami tablicy. Jedyną wartością jaką przechowuje u~siebie klient jest wspomniany identyfikator zapisany w~ciasteczkach. Jak sugeruje \cite{ClAu}, zastosowanie tego podejścia umożliwia przeprowadzanie ataku poprzez zgadnięcie identyfikatora, gdzie szansa na powodzenie rośnie wraz ze wzrostem liczby aktualnie zalogowanych użytkowników.

W~zamian \cite{ClAu} proponuje rozwiązanie przetrzymywania stanu sesji po stronie klienta. Sesja nie potrzebuje wtedy identyfikatora, gdyż całość informacji przechowywana jest w~wartości ciasteczka. Należy przy tym pamiętać, że skoro dane te znajdują się po stronie klienta, mogą zostać przez niego podmienione celem przeprowadzenia ataku. Do dobrych praktyk ochrony przed takim wydarzeniem należy dołączenie skrótu zawartości, sporządzonego przy użyciu tajnego klucza.

Proponowany przykład ma postać przedstawioną poniżej.
\begin{lstlisting}
exp=<EXPIRATION>&data=<DATA>&digest=MAC(exp=<EXPIRATION>&data=<DATA>)
\end{lstlisting}

Poniższy spis objaśnia wartości użyte w~ciasteczku.
\begin{description}
\item[<EXPIRATION>] \hfill \\
Wartość parametru \emph{exp}, określającego żywotność sesji, na przykład jako liczba sekund, które upłynęły od 00:00, 1 stycznia 1970 r.
\item[<DATA>] \hfill \\
Wartość parametru \emph{data}, który przechowuje wszelkie dane związane z~klientem, charakterystyczne dla implementowanej usługi.
\item[MAC(exp=<EXPIRATION>\&data=<DATA>)] \hfill \\
Wartość parametru \emph{digest}, będącego potwierdzeniem autentyczności danych przesyłanych od klienta. Dane te muszą zostać zabezpieczone przed ewentualną podmianą przez atakującego, więc dołączane są w postaci kodu \emph{MAC}\footnote{Message Authentication Code; Kod uwierzytelniania wiadomości}, który jest wynikiem funkcji skrótu, wykorzystującej tajny klucz, na danych mających być objętymi ochroną przed sfałszowaniem. Podmiana wartości parametrów \emph{exp} oraz \emph{data} zostanie z~łatwością wykryta poprzez porównanie załączonego skrótu ze skrótem wyliczonym w momencie otrzymania żądania, na podstawie tychże danych. Ze względu na wykorzystanie tajnego klucza w fazie liczenia skrótu, klient nie jest w~stanie sam wygenerować poprawnej jego wartości na podstawie sfałszowanych parametrów.
\end{description}

\cite{SeMa08} wymienia następujące zalety tego podejścia:
\begin{itemize}
\item Łatwiejsze w realizacji równoważenie obciążenia pomiędzy serwerami, oraz wysoka dostępność.
\item Mniejsze zużycie pamięci na serwerze.
\item Szybsze odpowiedzi i mniejszy koszt serwera, jako skutek braku potrzeby dedykowanego systemu równoważenia obciążenia.
\item Mniejsza złożoność wdrożenia.
\end{itemize}

%TODO? To wciąż cytat... dodać odnośnik?
W przechowywaniu sesji po stronie klienta istnieją również jednak pewne wady:
\begin{itemize}
\item Jeśli ciasteczko nie jest szyfrowane, stan sesji może zostać podsłuchany.
\item Stan przechowywany w~ciasteczku może zostać zmieniony, jeśli nie jest się przed tym odpowiednio zabezpieczonym (na przykład jak w zaprezentowanym powyżej przykładzie z~\emph{MAC}).
\item Rozmiar ciasteczek jest ograniczony, co zmniejsza również możliwości przechowywania sesji zawierających duże ilości danych.
\item Konieczne jest przesłanie większej ilości danych reprezentujących stan (w odróżnieniu do tylko jednej wartości - identyfikatora sesji - dla stanu trzymanego po stronie serwera).
\item Istnieje większa podatność na atak \emph{Replay}.
\item Unieważnianie sesji jest utrudnionym zadaniem, ponieważ serwer nie ma możliwości sprawdzić, które sesje zostały już zakończone.
\end{itemize}

Podejście, w~którym przechowuje się stan sesji po stronie klienta może być również bardzo korzystne dla aplikacji, które nie wymagają bazy danych do realizacji pozostałych funkcjonalności. Nie pasuje to jednak do profilu tworzonego systemu, wobec czego utworzenie dodatkowej tabeli dla sesji użytkowników nie jest problematyczne. Nie oczekuje się również, że system kiedykolwiek będzie wymagał równoważenia obciążenia, ze względu na wąskie grono jego użytkowników. Zgadnięcie identyfikatorów przez atakujących można znacznie zminimalizować poprzez zastosowanie wskazówek z~podrozdziału \ref{sec:identyfikator}. Ostatecznie przetrzymywanie sesji po stronie serwera wydaje się być bardziej trafionym podejściem dla tworzonego systemu.

Jak sugeruje \cite{ClAu} ciasteczka zawierające identyfikator sesji nie powinny być trwałe\footnote{tzn. nie powinno się deklarować atrybutu \emph{Expires} w nagłówku \emph{Set-Cookie}}, ponieważ zwiększa to ryzyko wykradnięcia poufnych danych. Jeśli dane te przetrzymywane są w~pamięci, dostęp do nich jest znacznie bardziej utrudniony. Dodatkowo jeżeli użytkownik loguje się do usługi z~publicznego urządzenia, kolejne osoby korzystające z~niego będą miały dostęp do konta poprzednika.

Z~punktu widzenie bezpieczeństwa najważniejsze jest, aby ciasteczko przechowujące identyfikator sesji spośród dostępnych atrybutów zawierało flagi \emph{Secure} oraz \emph{HttpOnly}.

\paragraph{Identyfikator}
\label{sec:identyfikator}

Użycie identyfikatora sesji pozwala na komunikację bez przesyłania hasła, więc należy zadbać o~to, aby był on odpowiednio bezpieczny. Każda osoba znająca (lub zgadująca) poprawny identyfikator może uzyskać dostęp do chronionych zasobów, więc jego poprawne zastosowanie jest równie ważne co obsługa początkowej fazy uwierzytelniania.

Jednym z~najważniejszych sposobów zminimalizowania prawdopodobieństwa odgadnięcia identyfikatora sesji jest ustalenie jego odpowiedniej długości. Zarówno \cite{SId} jak i~\cite{SeMa08} zalecają minimum 128-bitowy identyfikator.

Kolejnym, niemniej ważnym warunkiem jest korzystanie z~kryptograficznie bezpiecznego generatora liczb pseudolosowych (CSPRNG\footnote{Cryptographically Secure Pseudo-Random Number Generator}). Klasa \emph{Random} języka Java nie spełnia tego warunku. Każda kolejna losowana liczba, liczona jest na podstawie poprzedniej, co sprawia, że zastosowany algorytm bazujący na LCF\footnote{Linear Congruential Formula} jest przewidywalny. Jego zaletą jest szybkość, ale nie może być stosowany do generowania losowych wartości, na których opiera się bezpieczeństwo aplikacji. W języku \emph{Java} istnieje kryptograficznie bezpieczna alternatywa pod postacią klasy \emph{SecureRandom}. Źródłem jej entropii są nieprzewidywalne procesy systemowe czy sterowniki urządzeń \cite{RND}. Więcej na temat generatorów liczb pseudolosowych na platformie \emph{Java} można przeczytać w \cite{SRNGiJ}.

Dla lepszego zobrazowania bezpieczeństwa identyfikatora respektującego przedstawione wytyczne, warto przyjrzeć się wzorowi określającemu liczbę sekund potrzebną do zgadnięcia identyfikatora sesji, przedstawionemu w~\cite{SId}:

$\frac{2^{B} + 1}{2A \cdot S}$

gdzie \emph{A} jest liczbą prób zgadnięć identyfikatora, które atakujący jest w~stanie przeprowadzić w~ciągu sekundy, \emph{B} jest liczbą bitów entropii w~identyfikatorze, a~\emph{S} to liczba identyfikatorów sesji, które są aktualnie akceptowalne do użycia, czyli w~poprawnie funkcjonującym systemie jest to liczba aktualnie zalogowanych użytkowników.

Dla przykładu podstawiając pod A wartość $1000$, pod B wartość $64$ (szacuje się, że liczba bitów entropii w~\emph{CSPRNG} to połowa \cite{SId,SMC}; $128/2=64$), a~pod S $2000$ otrzymujemy $4,611686018\cdot10^{12}$ sekund, czyli $146235,604338768$ lat. Warto dodać, że podstawione wartości były znacznie zawyżone. Tak duża ilość zapytań z~pewnością zostałaby zablokowana przez firewall, a~liczbę użytkowników zalogowanych na raz w przypadku tworzonego systemu szacuje się na maksymalnie kilku.

%TODO wireshark, przykład

\subsection{Reset hasła}

Usługa resetowania zapomnianego hasła, zaimplementowana w~niewłaściwy sposób może prowadzić do bardzo prostych ataków na konta użytkowników, bez konieczności posiadania dużej wiedzy w~dziedzinie bezpieczeństwa. Przykładem tego jest sytuacja opisana w~\cite{FbB}, która dotyczy popularnego portalu społecznościowego jakim jest \emph{facebook}.

Kiedy dowolny użytkownik chciał zresetować swoje hasło został przekierowywany na stronę o~adresie
\begin{lstlisting}
https://www.facebook.com/checkpoint/checkpointme?f=[userid]&r=web_hacked
\end{lstlisting}

Niestety parametr \emph{f} zawierający nazwę użytkownika przesyłany metodą GET nie był w~żaden sposób zabezpieczony i~mógł zostać podmieniony na dowolną inną, poprawną wartość. Skutkowało to w~możliwości zresetowania hasła innym użytkownikom. Jak sugerują zrzuty ekranu załączone w cytowanym artykule formularz umożliwiał ustanowienie nowego hasła, a~co za tym idzie przejęcie całkowitej kontroli nad kontem.

Bezpieczny sposób resetowania hasła opisany w~\cite{CSH} korzysta z~czasowych tokenów uprawniających do wykonania tej wrażliwej operacji. W~aplikacji realizowanej na potrzeby niniejszej pracy zdecydowano się na implementację tego właśnie schematu.

Kiedy użytkownik zgłasza chęć zresetowania swojego hasła, przekierowywany jest do formularza gdzie wpisuje swój adres e-mail podany w~czasie rejestracji. Generowany jest jednorazowy token, który zapisywany jest w~bazie danych razem z~relacją do rekordu użytkownika, posiadającego adres zgodny z~podanym w formularzu oraz czasem wygenerowania zgłoszenia. Następnie, aby uniemożliwić poznanie tokenu innej osobie, na podany adres e-mail wysyłana jest wiadomość o~próbie resetu hasła wraz z~linkiem, który zawiera w~parametrze metody GET wygenerowany token i~prowadzi do formularza umożliwiającego wpisanie nowego hasła. Po jego wypełnieniu sprawdzana jest wartość tokenu. Jeśli znajduje się w~bazie danych i~od czasu wygenerowania tokenu nie minęło więcej czasu niż z~góry określona wartość\footnote{w~implementowanej aplikacji jako limit czasu na realizację tokenu przyjęto wartość 15 minut}, skojarzonemu z~nim użytkownikowi zmienia się hasło, generując również nową sól (patrz \ref{sec:sol}).

Taki sam scenariusz realizowany jest niezależnie od tego czy użytkownik podejmuje akcję zmiany hasła korzystając z ustawień swojego konta będąc zalogowanym, czy nie pamięta swoich danych uwierzytelniających i~nie jest w stanie się zalogować.

Oczywiście należy pamiętać, że tak jak w przypadku soli, czy identyfikatora sesji konieczne jest skorzystanie z kryptograficznie bezpiecznych generatorów liczb pseudolosowych (\emph{CSPRNG}), o~których więcej wspomniano w podrozdziale \ref{sec:identyfikator}. W~przeciwnym wypadku atakujący mógłby dokonać próby resetu własnego hasła, a~następnie otrzymując swój token starać się przewidzieć jaka będzie kolejna wylosowana wartość i~wykorzystać ją w~celu zresetowania hasła innemu użytkownikowi.

\subsection{Ochrona wybranych zasobów}
\label{sec:ochronaWybranychZasobow}

Kiedy użytkownik otwiera stronę internetową w~przeglądarce, żądanie trafia do kontenera aplikacji (dla przykładu \emph{Tomcat}) parsuje jego adres URL i~kieruje do odpowiedniej aplikacji. Następnie jest ono kierowane do jednego z~jej zasobów (np. serwletu), według definicji znajdujących się w~deskryptorze \emph{web.xml} aplikacji. Twórca systemu ma możliwość zdecydowania, na którym etapie chce sprawdzić autentyczność klienta.

W przedstawionym przykładzie znacznie lepszym podejściem byłoby wykonanie tej operacji już na etapie rozpatrywania żądania przez kontener. Jego konfiguracja pozwala na zdefiniowanie przestrzeni adresów URL, które mają być chronione\footnote{W najprostszych przypadkach, takich jak implementowany system jest to cała aplikacja, na przykład: ``/dentaise'', gdzie automatycznie chronione byłyby również podzasoby, to znaczy ``/dentaise/doctors/'' itp\ldots}. W przeciwnym wypadku programista musiałby pamiętać o~sprawdzeniu danych uwierzytelniających w~każdym zasobie, do którego można się dostać z~zewnątrz, włączając w~to wszystkie podstrony i~metody WebService'ów. Takie podejście narażałoby aplikację na poważne luki w~bezpieczeństwie i byłoby niewygodne w rozwoju.

Kontener \emph{Tomcat} pozwala na konfigurację opisywanych w~pracy schematów \emph{Basic}, \emph{Digest}, oraz \emph{Form}. W przypadku realizowanej metody \emph{Form Access Authentication} poprawnym sposobem byłoby zdefiniowanie w~deskryptorze \emph{web.xml} relatywnych ścieżek do stron z~formularzem logowania oraz informacją o~błędzie i~zdefiniowanie połączenia \emph{JDBC} do bazy danych, wraz z~ustaleniem nazw tabel i~kolumn potrzebnych do przeprowadzenia operacji uwierzytelniania. Dokładny sposób konfiguracji tego przypadku opisany został w~\cite{JRUA}.

Nie zawsze jednak uwierzytelnianie po stronie aplikacji, zamiast kontenera jest złym podejściem. W~wyjątkowych przypadkach może być ono realizowane przez wykorzystywany \emph{framework}. Istnieje również możliwość zaimplementowania własnych mechanizmów chroniących zasoby\footnote{Implementacja powinna jednak pozwalać na wygodne jej wykorzystanie, na przykład przy pomocy adnotacji jak jest to zrealizowane w~wypadku \emph{Play Framework}. Pozwoli to uchronić się przed pamiętaniem o~przeprowadzeniu operacji uwierzytelniania w~każdej metodzie.}, dopóki tylko posiada się dostęp do oryginalnego żądania.

Implementowana aplikacja w celu uwierzytelniania korzysta z~adnotacji dostępnych w~\emph{Play Framework}. Utworzona została klasa respektująca zalecenia opisane w rozdziale \ref{sec:uwierzytelnianie}, która sprawdza stan sesji użytkownika jeśli kontroler lub wywoływana w nim metoda są adnotowane \emph{@Secured}. Jeżeli użytkownik nie przesłał w Cookie identyfikatora sesji, zostanie przekierowany do strony logowania. W przeciwnym wypadku z~bazy danych dla otrzymanego identyfikatora pobierany jest czas ostatniej akcji w sesji i~jeśli nie przekroczył on ustalone 30 minut, zostaje odświeżony do aktualnego, a~użytkownikowi wyświetlona zostają pożądana podstrona. Po przekroczeniu półgodzinnego limitu braku akcji, użytkownik przy próbie wysłania żądania zostaje wylogowany i~skierowany do strony logowania.
 
\subsection{HTTPS}
\label{sec:https}

Szyfrowanie ruchu jest niezmiernie ważnym elementem bezpieczeństwa. Jest to szczególnie istotne podczas procesu logowania, ponieważ w~wybranym schemacie dane uwierzytelniające przesyłane są w~czystej postaci. Nie należy jednak ograniczać się do zabezpieczenia tylko tego etapu korzystania z~usługi. Po zalogowaniu się użytkownik nie przesyła już swojego hasła, ale posługuje się identyfikatorem sesji, który w tym wypadku jest równie poufną informacją. W~przypadku podsłuchania ruchu, atakujący będzie mógł przejąć kontrolę nad kontem użytkownika podstawiając w~Cookie jego identyfikator sesji. Serwer nie będzie miał możliwości zweryfikować czy komunikuje się z~nim inna osoba, ponieważ identyfikator jest jedynym elementem potrafiącym je rozróżnić i w~wypadku gdy jest taki sam, z~punktu widzenia serwera jest to również ten sam użytkownik. Dodatkowym zabezpieczeniem mogłoby być przetrzymywanie w~bazie danych adresu IP z~jakiego łączy się klient i~sprawdzanie czy nie zmienił się przy kolejnych żądaniach. Nie ma jednak takiej konieczności jeśli odpowiednio zadba się o~szyfrowanie komunikacji. 

%TODO HTTPS w play

\subsection{SQL Injection}

Najpopularniejszym rodzajem ataku ukierunkowanym w~stronę luk bezpieczeństwa znajdującym się w~warstwie połączenia z~bazą danych bez wątpienia jest \emph{SQL Injection}. Metoda pozwala na modyfikację zapytań, które częściowo składają się z~danych podawanych przez użytkownika.

Przykład przedstawiony w~\cite{PSqlI} wykorzystuje atak, aby zalogować się w~usłudze bez znajomości nazwy użytkownika i~hasła, wypełniając jedynie w~odpowiedni sposób pola dostępne w~formularzu. Do przytoczonego przykładu warto dodać, że po stronie serwera uwierzytelnianie odbywa się przy pomocy zapytania języka \emph{SQL} uformowanego poprzez konkatenację wartości stałych ze zmiennymi dostarczonymi od klienta, na wzór poniższej instrukcji.

\begin{lstlisting}[language=Java]
String query = "SELECT * FROM users WHERE login='" + login + "' AND pwd='" + password + "'";
\end{lstlisting}

Zmienne \emph{login} oraz \emph{password} zaczerpnięte są z~formularza i~kiedy użytkownik wypełni go wartościami \emph{adam} i~\emph{s3cret} powyższy ciąg znaków zostanie złożony w~następującą całość.

\begin{lstlisting}[language=SQL]
SELECT * FROM users WHERE login='adam' AND pwd='s3cret'
\end{lstlisting}

Tabela użytkowników sprawdzona zostanie pod kątem przekazanych danych i~jeśli obydwie wartości będą się zgadzać zwrócony zostanie wiersz, który będzie odpowiadał właśnie zalogowanemu użytkownikowi.

Jeżeli jednak w polu użytkownika podany zostanie ciąg [\lstinline$' OR 1=1 --$]\footnote{W języku \emph{SQL} ciąg znaków [\lstinline$--$] rozpoczyna komentarz, więc dalsza część zapytanie zostanie zignorowana}, a w~polu hasła [\lstinline$ $] ostatecznie zapytanie przybierze poniższą postać.

\begin{lstlisting}[language=SQL]
SELECT * FROM users WHERE login='' OR 1=1 --' AND pwd=' '
\end{lstlisting}

Powyższa instrukcja jest logicznie tożsama z pobraniem listy wszystkich użytkowników, więc uwierzytelnienie powiedzie się i atakujący zostanie zalogowany.

W~celu uchronienia się przed tą metodą należy unikać ręcznej konkatenacji zapytań. W~\cite{sql-injection-prevention-cheat-sheet} wyszczególnia się następujące trzy sposoby poprawnej komunikacji z~bazą danych:

\begin{description}
\item[Zapytania parametryzowane] \hfill \\
W~odróżnieniu od podejścia zaprezentowanego w~przykładzie, gdzie całe zapytanie składane jest ręcznie, polegają one na wcześniejszym przygotowaniu kwerendy, uwzględniając w~niej niewiadome, których wartości zostaną dostarczone w czasie późniejszym. Takie podejście pozwala na automatyczne sprawdzenie dostarczanych danych pod kątem zawartości znaków pozwalających na modyfikację zapytania.
\item[Procedury składowane] \hfill \\
Podobnie jak zapytania parametryzowane pozwala na wcześniejszą definicję kwerendy, z~tą różnicą, że będzie ona przetrzymywana po stronie bazy danych.
\item[Sekwencja ucieczki] \hfill \\
Wszelkie specjalne znaki zostaną poprzedzone przez znak ucieczki, przez co cały wkład użytkownika zostanie potraktowany jako jedna wartość. W omówionym przykładzie atakującemu nie udałoby się zamknąć warunku sprawdzenia loginu więc cały ciąg [\lstinline$' OR 1=1 --$] wykorzystany zostanie jako nazwa użytkownika do wyszukania.
\end{description}

W~implementowanej aplikacji do konstrukcji kwerend wykorzystano bezpieczne zapytania parametryzowane oraz \emph{JPA\footnote{Java Persistence API} Criteria API}. W~zamieszczonym poniżej listingu zawarto przykład wyszukiwania lekarzy o~danym adresie e-mail z~wykorzystaniem zapytań parametryzowanych.

\begin{lstlisting}[language=Java]
TypedQuery<Doctor> query = JPA.em().createQuery("FROM Doctor d WHERE d.email=:email", Doctor.class);
query.setParameter("email", email);
List<Doctor> doctors = query.getResultList();
\end{lstlisting}

\subsection{Cross-site scripting}

Atak, zapisywany często również jako \emph{XSS} lub \emph{CSS}\footnote{Nie mylić z Cascading Style Sheets, językiem służącym do opisu prezentacji stron WWW}, który podobnie jak \emph{SQL Injection} pozwala na wstrzyknięcie złośliwego kodu. Ukierunkowany jest on na stronę kliencką i~jego najczęstszym celem jest wykradnięcie poufnych danych, na przykład znajdujących się w~Cookies, zwykle poprzez dodanie kodu \emph{JavaScript}, który uruchomiony zostanie w przeglądarce ofiary \cite{XSSE}.

Wstrzyknięty kod może zostać opublikowany na stronie, przykładowo w~zamieszonym komentarzu do wpisu bloga. Ofiarą staje się wtedy każdy odwiedzający stronę WWW, ponieważ atakujący może w~ten próbować dostać się do zawartości Cookies i~przesyłać ją w ustalone przez siebie miejsce, bez świadomości atakowanego użytkownika. Dlatego niezmierne ważne jest również zabezpieczenie się przed nieuprawnionym dostępem do Cookies, co opisane zostało w~podrozdziale \ref{sec:cookies}. Oczywiście prawidłowa ochrona przed atakiem \emph{Cross-site Scripting} również skutecznie powstrzyma atak, ale niewłaściwa konfiguracja ciasteczek może przyczynić się do umożliwienia dostępu do nich spoza własnej usługi, gdzie taki atak będzie możliwy.

Aby skutecznie obronić się przed atakiem \emph{Cross-site Scripting}, należy zapewnić podmianę znaków specjalnych w~danych przesyłanych przez użytkowników, tak aby nie były traktowane jako część dokumentu \emph{HTML}, a~ciąg znaków do wyświetlenia.

\emph{Play Framework} domyślnie koduje znaki w danych przesyłanych pomiędzy kontrolerem, a szablonem strony. Dla pewności wykonano testy dostępne w \cite{XSST}. W polu notatek okna wizyty wklejono następującą treść.

\begin{lstlisting}[language=HTML]
';alert(String.fromCharCode(88,83,83))//';alert(String.fromCharCode(88,83,83))//";
alert(String.fromCharCode(88,83,83))//";alert(String.fromCharCode(88,83,83))//--
></SCRIPT>">'><SCRIPT>alert(String.fromCharCode(88,83,83))</SCRIPT>
\end{lstlisting}

Jeżeli atak się powiedzie, po odświeżeniu strony powinno pojawić się okienko z~treścią ``XSS''. Strona wyświetliła się poprawnie wyświetlając znaki wprowadzone przez użytkownika, nie interpretując nowej funkcjonalności ze wstrzykniętego kodu. Po zaglądnięciu w źródło strony rzeczywiście okazało się, że znaki specjalne zostały poprawnie zakodowane.

\begin{lstlisting}[language=HTML]
<div class="form-group">
    <label for="notes" class="col-lg-2 control-label">Notatki</label>
    <div class="col-lg-10">
        <textarea name="notes" placeholder="Dodatkowe informacje..." class="form-control" rows="5">&#x27;;alert(String.fromCharCode(88,83,83))//&#x27;;alert(String.fromCharCode(88,83,83))//&quot;;

alert(String.fromCharCode(88,83,83))//&quot;;alert(String.fromCharCode(88,83,83))//--

&gt;&lt;/SCRIPT&gt;&quot;&gt;&#x27;&gt;&lt;SCRIPT&gt;alert(String.fromCharCode(88,83,83))&lt;/SCRIPT&gt;</textarea>
    </div>
</div>
\end{lstlisting}

%----------------------------------------------------------------------------

\chapter{Konfiguracja i uruchomienie}
%TODO dane, wykonanie sql...
\label{cha:konfiguracja_i_uruchomienie}
a może jako dodatek zamiast rozdziału?

\subsection{Baza danych}
\subsection{Play Framework}
%pamiętaj o https
\subsubsection{Instalacja}
\subsubsection{Plik application.conf}
baseUrl, smtp.host, database itp...
\subsection{Android SDK}
\subsection{Zależności}
\subsubsection{Sbt}
\subsubsection{Gradle}
\subsection{Uruchomienie}

% itd.
% \appendix
% \include{dodatekA}
% \include{dodatekB}
% itd.

\bibliographystyle{alpha}
\bibliography{bibliografia}

\end{document}
