\documentclass[11pt]{aghdpl}
% \documentclass[en,11pt]{aghdpl}  % praca w języku angielskim
\renewcommand{\labelitemi}{$\bullet$}

\usepackage[polish]{babel}
%\usepackage[english]{babel}
\usepackage[utf8]{inputenc}

% dodatkowe pakiety
\usepackage{enumerate}
\usepackage{mathtools}
\usepackage{listings}
\lstloadlanguages{TeX}

\lstset{
frame=single,
breaklines=true,
postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}},
literate={ą}{{\k{a}}}1
{ć}{{\'c}}1
{ę}{{\k{e}}}1
{ó}{{\'o}}1
{ń}{{\'n}}1
{ł}{{\l{}}}1
{ś}{{\'s}}1
{ź}{{\'z}}1
{ż}{{\.z}}1
{Ą}{{\k{A}}}1
{Ć}{{\'C}}1
{Ę}{{\k{E}}}1
{Ó}{{\'O}}1
{Ń}{{\'N}}1
{Ł}{{\L{}}}1
{Ś}{{\'S}}1
{Ź}{{\'Z}}1
{Ż}{{\.Z}}1
}

%---------------------------------------------------------------------------

\author{Mateusz Kulpa}
\shortauthor{M. Kulpa}

\titlePL{Projekt i~implementacja mobilnego systemu wspomagającego prowadzenie gabinetu lekarskiego w technologii JavaEE oraz Android}
\titleEN{Design and implementation of mobile doctors office management system using JavaEE and Android technologies}

\shorttitlePL{Projekt i~implementacja mobilnego systemu wspomagającego prowadzenie gabinetu lekarskiego w technologii JavaEE oraz Android}
\shorttitleEN{Skrócony tytuł angielski}

\thesistype{Praca dyplomowa magisterska}

\supervisor{dr inż.\ Paweł Skrzyński}

\degreeprogramme{Informatyka}

\date{2014}

\department{Katedra Informatyki Stosowanej}
%\department{Department of Applied Computer Science}

\faculty{Wydział Elektrotechniki, Automatyki,\protect\\[-1mm] Informatyki i Inżynierii Biomedycznej}
%\faculty{Faculty of Electrical Engineering, Automatics, Computer Science and Biomedical Engineering}

\acknowledgements{Serdecznie dziękuję \dots tu ciąg dalszych podziękowań np. dla promotora, żony, sąsiada itp.}


\setlength{\cftsecnumwidth}{10mm}

%---------------------------------------------------------------------------
%TODO Cytaty ``''
%TODO Content Negotiation
%TODO StringEntity entity = new StringEntity(mapper.writeValueAsString(patient), HTTP.UTF_8);
%TODO Maintenece - spójność api - latwiejsze w utrzymaniu, klient ma tylko widok i pobiera dane z ws łącznie ze zdefiniowanymi leczeniami/rozpoznaniami. Dzięki temu nie trzeba będzie aktualizować obydwu aplikacji, a jedynie zdefiniować nowe leczenie/rozpoznanie po stronie serwera. Gdyby api było zewnętrzne to warto by się pokusić o oddzielny interjefs, skoro jest tylko wew. wygodniej będzie utrzymywać jeden
%TODO ajax, jquery?
%TODO play - formularze z zagnieżdżonymi obiektami oraz listami
%TODO? hibernate, jackson, lazy-load (VisitController.list)

\setcounter{secnumdepth}{3}

\begin{document}


\titlepages

\begin{abstract}

Niniejsza praca opisuje etapy implementacji narzędzia wspomagającego pracę gabinetu lekarskiego. Głównym podmiotem pracy nie jest stworzenie kompletnego rozwiązania dla lekarzy zgodnego z~ obowiązującymi normami, a przedstawienie sposobu implementacji systemu składającego się  z~kilku komponentów, z~którego można korzystać przy pomocy przeglądarki internetowej oraz aplikacji dedykowanej na platformę Android. Ze względu na duże zróżnicowanie potrzeb w zależności od dziedziny medycyny zdecydowano się na implementację narzędzia przeznaczonego dla gabinetu dentystycznego. 

W pracy poruszane są kwestie projektowania aplikacji biznesowej pod kątem dostępnych obecnie technologii z~naciskiem na interfejsy poszczególnych warstw. Szczegółowo opisywane są również typowe problemy bezpieczeństwa z~jakimi trzeba się zmagać podczas implementacji poszczególnych modułów takie jak uwierzytelnianie, bezpieczny mechanizm resetu hasła czy ataki Replay oraz SQL Injection.

Pomimo zawężenia problemu do wielkości pozwalającej skupieniu się na szczegółach projektowania i~ implementacji, opisywany system realizuje w podstawowym stopniu potrzeby związane z prowadzeniem przychodni stomatologicznej i~może zostać dlań wykorzystany.

\end{abstract}

\setcounter{tocdepth}{3}
\tableofcontents
\clearpage

%----------------------------------------------------------------------------

\chapter{Wstęp}
\label{cha:wstep}
%TODO problem spójności api
%TODO praca odnosi się do konkretnych frameworków i niektóre rozwiązania są do zastosowania tylko w ich obrębie, ale niektóre zagadnienia mają charakter ogólny
\section{Cele pracy}
\label{sec:cele_pracy}
%TODO
\section{Zawartość pracy}
\label{sec:zawartosc_pracy}
%TODO
%----------------------------------------------------------------------------

\chapter{Architektura}
\label{cha:architektura}
%TODO
\section{Architektura fizyczna}
\label{sec:architektura_fizyczna}
%TODO
\section{Architektura logiczna}
\label{sec:architektura_logiczna}
%TODO
%----------------------------------------------------------------------------

\chapter{Dobór technologii i narzędzi}
\label{cha:dobor_technologii_i_narzedzi}

W rozdziale tym opisane zostały technologie i~narzędzia użyte do implementacji każdej z~warstw aplikacji. Nie uwzględniono przy tym bibliotek zastosowanych do rozwiązania konkretnych problemów dla danej warstwy, a~jedynie elementy niezbędne do zrozumienia struktury systemu i~sposobu komunikacji pomiędzy poszczególnymi modułami.

%TODO dopisać coś o Javie

\section{Baza Danych}
\subsection{System zarządzania relacyjnymi bazami danych}
\subsection{Mapowanie obiektowo-relacyjne}
\section{Web Service}
\subsection{Protokół}
\subsubsection{SOAP}
\subsubsection{REST}
\subsubsection{Wybór i uzasadnienie}
\subsection{Serializacja}
jackson
\section{Moduł web}
\subsection{Back-end}
playframework
\subsection{Front-end}
bootstrap, javascript, jquery, html, css
\section{Moduł mobile}
\subsection{Platforma}
Android
\subsection{Klient WebService}
ApacheHttpClient
\section{Zarządzanie zależnościami}
\subsection{Sbt}
\subsection{Gradle}

%----------------------------------------------------------------------------

\chapter{Implementacja}
\label{cha:implementacja}

\section{MVC}

\subsection{Modele}

\subsection{Widoki}

%jedyne miejsce zmienne dla urządzeń!!

\subsubsection{Web}

\subsubsection{Mobile}

\subsection{Kontrolery}

%TODO CRUD, transakcje, acid?

\section{Web Service}

\subsection{API}

``rozdwojenie'' API dla web i mobile

zalecany interfejs restowy a ograniczenia html: brak PUT, DELETE; paginacja w url czy header Range?

\section{Bezpieczeństwo}

\subsection{Uwierzytelnianie}

Uwierzytelnianie jest pojęciem powszechnie rozumianym jako potwierdzenie tożsamości deklarowanej przez podmiot. W informatyce proces ten wykorzystywany jest kiedy zależy nam na uniemożliwieniu dostępu do danych treści osobom nieupoważnionym, a~więc jest nieodłącznym elementem wszelkich usług (m.in. stron internetowych), przechowujących prywatne dane przeznaczone dla każdego użytkownika z~osobna.

W wypadku aplikacji tworzonej w~ramach pracy, proces uwierzytelniania musi zostać zaimplementowany po stronie serwera Dentaise i~być jednakowo stosowany przez strony klienckie - webową oraz mobilną. Należy więc tak dobrać metodę, aby była możliwa do realizacji na tych dwóch różnych platformach.

\subsubsection{Różne podejścia}

Istnieją różne podejścia pozwalające potwierdzić autentyczność podmiotu, najpopularniejsze z~których zostaną zaprezentowane w~dalszej części tego podrozdziału. Każde z~nich będzie opierać się na podobnym schemacie. 

Pierwszym krokiem jest podanie przez użytkownika pary danych - jego nazwy oraz hasła - a~następnie przesłanie ich i~potwierdzenie zgodności z~danymi przetrzymywanymi w~bazie po stronie serwera. Należy przy tym pamiętać, aby dane te były przechowywane w~sposób nie narażający użytkownika na wyciek ich czytelnej postaci, w~przypadku uzyskania nieautoryzowanego dostępu do bazy przez osoby trzecie. Więcej informacji na ten temat można przeczytać w~podrozdziale \ref{sec:hashowanie}. 

Następnie na podstawie dostarczonych danych, w~wypadku ich pozytywnego rozpatrzenia, nawiązywana jest sesja (podrozdział \ref{sec:sesja}), którą użytkownik identyfikuje się  podczas wysyłania kolejnych żądań do serwera. Identyfikacja przy pomocy sesji jest zautomatyzowana i~ niewidoczna dla użytkownika. Czas trwania sesji zwykle jest ograniczony i~wygasa ona po dłuższym okresie nieaktywności, zmuszając do powtórzenia procesu uwierzytelnienia aby ponownie pozyskać dostęp do treści.

\paragraph{Basic Access Authentication}

Jest to podstawowa metoda uwierzytelniania, gdzie wymagane dane uzupełniane są w specjalnych nagłówkach protokołu HTTP, a więc może być wykorzystywany między innymi przez strony internetowe oraz WebService'y. Uwierzytelnianie tą metodą  przebiega w sposób przedstawiony poniżej. Do lepszego zobrazowania wymiany komunikatów pomiędzy serwerem a klientem (przeglądarką) posłuży przechwycona sesja próby dostępu do menadżera aplikacji na kontenerze Tomcat.

%Użytkownik wysyła żądanie HTTP, przykładowo celem wyświetlenia zawartości strony internetowej, które jak się okazuje podczas jego analizy po stronie serwera dotyczy chronionego zasobu. Serwer zwraca odpowiedź o statusie \emph{401 Unauthorized}, która zawiera w nagłówku \emph{WWW-Authenticate} schemat uwierzytelniania (w tym wypadku \emph{Basic}) oraz nazwę strefy (\emph{realm}), do której należy treść jaką chce pozyskać użytkownik. Zgodnie z \cite{BDA99} nazwa strefy może być dowolna i jest ustalana po stronie serwera. Każdy zasób chroniony pod tą samą strefą (zwracający ten sam \emph{realm} w odpowiedzi \emph{Unauthorized}), musi być dostępny za pomocą tych samych danych uwierzytelniających.

Celem wyświetlenia zawartości strony internetowej, a w tym wypadku menedżera aplikacji znajdującego się na lokalnym kontenerze tomcat użytkownik wprowadza w przeglądarce internetowej adres \emph{http://localhost:8080/manager/html}. Przeglądarka wysyła następujące żądanie.
\begin{lstlisting}
GET /manager/html HTTP/1.1
Host: localhost:8080
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/33.0.1750.152 Chrome/33.0.1750.152 Safari/537.36
Accept-Encoding: gzip,deflate,sdch
Accept-Language: pl-PL,pl;q=0.8,en-US;q=0.6,en;q=0.4
Cookie: JSESSIONID=589E30C58F80986353A1C6A6B9BC02ED
\end{lstlisting}

Jak się okazuje podczas analizy żądania po stronie serwera, dotyczy ono chronionego zasobu. Sposób w jaki określa się, które zasoby są chronione przybliżony został w podrozdziale \ref{sec:ochronaWybranychZasobow}. W tym momencie wystarczy wiedzieć, że w wypadku \emph{Basic Access Authentication}, dzięki temu że należy do standardu HTTP większość serwerów WWW i kontenerów aplikacji pozwala na wygodną konfigurację poprzez wpisanie adresów URL mających być pokrytymi ochroną, oraz sprecyzowanie listy użytkowników wraz z hasłami dostępu. Ewidentną wadą tego podejścia jest jednak statyczna baza użytkowników, nic jednak nie stoi na przeszkodzie, aby zaimplementować obsługę opisywanego schematu po stronie własnej aplikacji webowej.

Serwer zwraca odpowiedź o statusie \emph{401 Unauthorized}, która zawiera w nagłówku \emph{WWW-Authenticate} schemat uwierzytelniania (w tym wypadku \emph{Basic}) oraz nazwę strefy (\emph{realm}), do której należy treść jaką chce pozyskać użytkownik. Zgodnie z \cite{BDA99} nazwa strefy może być dowolna i jest ustalana po stronie serwera. Każdy zasób chroniony pod tą samą strefą (zwracający ten sam \emph{realm} w odpowiedzi \emph{Unauthorized}), musi być dostępny za pomocą tych samych danych uwierzytelniających.
\begin{lstlisting}
HTTP/1.1 401 Unauthorized
Server: Apache-Coyote/1.1
Cache-Control: private
Expires: Thu, 01 Jan 1970 01:00:00 CET
WWW-Authenticate: Basic realm="Tomcat Manager Application"
Content-Type: text/html;charset=ISO-8859-1
Transfer-Encoding: chunked
Date: Tue, 12 Aug 2014 15:58:57 GMT

(... zawartość)
\end{lstlisting}

W odpowiedzi na otrzymany komunikat przeglądarka reaguje wyświetlając okno logowania. Nie jest ono częścią strony do której dostęp chce uzyskać użytkownik, jego obsługa zaimplementowana jest w~całości w~przeglądarce. Kolejną zaletą tej metody jest więc brak konieczności implementacji formularza logowania.

Po wypełnieniu danych użytkownik ponawia próbę żądania, tym razem jednak załączone zostaną dane potwierdzające jego tożsamość w nagłówku \emph{Authenticate}. Wartość nagłówka również zawiera wykorzystywany schemat (\emph{Basic}), ale oprócz tego zakodowaną w~Base64 nazwę użytkownika oraz jego hasło, oddzielone przez dwukropek (\emph{:}). Aby umożliwić stronie serwerowej poprawne oddzielenie danych po ich zdekodowaniu, nazwa użytkownika nie może zawierać tego znaku.
\begin{lstlisting}
GET /manager/html HTTP/1.1
Host: localhost:8080
Connection: keep-alive
Cache-Control: max-age=0
Authorization: Basic dG9tY2F0OnRvbWNhdA==
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/33.0.1750.152 Chrome/33.0.1750.152 Safari/537.36
Accept-Encoding: gzip,deflate,sdch
Accept-Language: pl-PL,pl;q=0.8,en-US;q=0.6,en;q=0.4
Cookie: JSESSIONID=589E30C58F80986353A1C6A6B9BC02ED
\end{lstlisting}

Tym razem klient otrzymuje pozytywną odpowiedź wraz z kodem HTML w~zawartości odpowiedzi, który wyświetli przeglądarka (zawartość została wycięta, gdyż nie jest istotna w~rozpatrywaniu niniejszego procesu).
\begin{lstlisting}
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
Cache-Control: private
Expires: Thu, 01 Jan 1970 01:00:00 CET
Set-Cookie: JSESSIONID=3EE8A15F1F9714D7E390F9F1E36FC8F7; Path=/manager/; HttpOnly
Content-Type: text/html;charset=utf-8
Transfer-Encoding: chunked
Date: Tue, 12 Aug 2014 15:59:02 GMT

(... zawartość)
\end{lstlisting}

Kolejne żądania do tej samej strefy nie wymagają ponownego wypełnienia formularza, ponieważ dane zostają zapamiętane w przeglądarce i są załączane automatycznie. Użytkownik nie musi dbać o ponowne podawanie swoich danych na czas trwania sesji. Niestety standard ten nie pozwala w prosty sposób obsłużyć opcji wylogowania się (zakończenia sesji przed czasem).

Warto zauważyć, że dane przesyłane są w niezaszyfrowanej postaci (\emph{clear text}), więc mogą zostać przywrócone do swojej oryginalnej formy, jaką podaje w oknie logowania użytkownik, po zdekodowaniu zawartości nagłówka \emph{Authorization} przy pomocy tego samego algorytmu, który został użyty do ich zakodowania czyli \emph{Base64}. \emph{Basic access authentication} dla zapewnienia bezpieczeństwa wymaga zastosowania dodatkowego protokołu szyfrującego, ponieważ dane uwierzytelniające mogą zostać odczytane przez każdą osobę mogącą przechwycić pakiet z wysyłanym żądaniem. Zwykle w tym celu stosuje się szyfrowaną wersję protokołu \emph{HTTP} czyli \emph{HTTPS}.

\paragraph{Digest Access Authentication}
%TODO? w razie potrzeby będzie można uzupełnić o dokładny sposób tworzenia skrótu

Ze względu na to, że w schemacie \emph{Basic Access Authentication} dane uwierzytelniające użytkownika są przesyłane w postaci niezaszyfrowanej, nie można go uznać za bezpieczny jeśli nie skorzysta się z dodatkowej warstwy zapewniającej szyfrowanie komunikacji. \emph{Digest Access Authentication} jest jego usprawnieniem pod kątem bezpieczeństwa przesyłanych danych.

Schemat komunikacji wygląda podobnie jak w poprzednim wypadku. Do prześledzenia wymiany komunikatów pomocny będzie przykład z \cite{BDA99}.

Pierwsze żądanie nie różni się niczym od zawartego w przykładzie z \emph{Basic Access Authentication} poza zmianą zasobu, który chcemy uzyskać. W tym wypadku serwer również odsyła odpowiedź \emph{401 Unauthorized}, jednak zawiera ona znacznie więcej danych.

Oprócz parametru \emph{realm} omówionego wcześniej, w odpowiedzi zwrotnej mogą znaleźć się następujące pola:
\begin{description}
\item[domain] \hfill \\
Lista adresów przypadających pod strefę określoną w \emph{realm}. Te same dane uwierzytelniające powinny pozwolić klientowi uzyskać dostęp do wszystkich wymienionych w tym polu zasobów.
\item[nonce] \hfill \\
%TODO? nonce jest ogólnym pojęciem, można o nim coś więcej napisać...
Wartość ustalana przez serwer. Jest użyta jako unikalny fragment hashowanych ciągów, aby uniemożliwić przeprowadzenie ataku przez powtórzenie. W tym celu serwer powinien zwracać unikalną wartość dla każdej odpowiedzi \emph{401 Unauthorized}. Zwykle jest ciągiem znaków zakodowanym w Base64 lub zapisanym w systemie heksadecymalnym, który zawiera w sobie między innymi aktualny czas, aby umożlić sprawdzenie, czy odpowiedź klienta nie przyszła po zbyt długim czasie.
\item[opaque] \hfill \\
Ciąg znaków ustalany przez serwer, który powinien być zwrócony w niezmienionej postaci przez klienta. Może zostać użyty do przesyłania dodatkowych informacji, na przykład kiedy za uwierzytelnianie odpowiada serwer inny niż hostujący zasób, do którego klient chce uzyskać dostęp. W tym celu można jednak również wykorzystać pole \emph{nonce}.
%TODO? hash? z ang. hash?
\item[stale] \hfill \\
Flaga ustawiana na \emph{TRUE} jeżeli otrzymane żądanie zawierało przeterminowany \emph{nonce}, ale dane uwierzytelniające wraz z nim tworzą poprawny skrót\footnote{Wynik funkcji skrótu (hash)}. Umożliwia to powtórzenie żądania z nowym \emph{nonce}, bez ponownego angażowania użytkownika końcowego w podawanie loginu i hasła.
\item[algorithm] 
\hfill \\Wybrany algorytm funkcji skrótu (domyślnie \emph{MD5}).
\item[qop] \hfill \\
Pole opcjonalne (\emph{quality of protection}). W celu zapewnienia kompatybilności wstecznej może zostać pominięte. W zależności od wyboru skrót będzie komponowany na podstawie innego zestawu danych. Dozwolone wartości to \emph{auth} i \emph{auth-int}, spośród których serwer może wysłać dowolną kombinację. Na podstawie zwróconych możliwości strona kliencka będzie mogła dokonać wyboru odsyłając jedną z nich lub całkowicie je pomijając. Jeżeli jednak odpowiedź serwera zawiera to pole, zaleca się, aby klient również je uwzględnił.
\item[auth-param] \hfill \\
Pole służące do przyszłych rozszerzeń.
\end{description}

Przykładowa odpowiedź serwera będzie wyglądać następująco.
\begin{lstlisting}
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Digest
realm="testrealm@host.com",
qop="auth,auth-int",
nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
opaque="5ccc069c403ebaf9f0171e9517f40e41"
\end{lstlisting}

Podobnie jak w przykładzie dotyczącym \emph{Basic Access Authentication} klient musi na nie odpowiedzieć, umieszczając dane uwierzytelniające w nagłówku \emph{Authenticate}. Użytkownikowi wyświetli się okno logowania obsługiwane przez przeglądarkę, gdzie może podać swój login i hasło, a następnie dane te zostaną przetworzone, dając w wyniku nagłówek, który zostanie przesłany w powtórzonym żądaniu do serwera.
\begin{lstlisting}
Authorization: Digest username="Mufasa",
realm="testrealm@host.com",
nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
uri="/dir/index.html",
qop=auth,
nc=00000001,
cnonce="0a4f113b",
response="6629fae49393a05397450978507c4ef1",
opaque="5ccc069c403ebaf9f0171e9517f40e41"
\end{lstlisting}

\begin{description}
\item[username] \hfill \\
Nazwa użytkownika w czystej postaci.
\item[realm] \hfill \\
Nazwa strefy przesłana przez serwer wraz z odpowiedzią \emph{401 Unauthorized}.
\item[nonce] \hfill \\
Unikalna wartość przesłana przez serwer wraz z odpowiedzią \emph{401 Unauthorized}.
\item[uri] \hfill \\
URI zasobu, który chce uzyskać klient. Ta sama wartość (\emph{Request-URI})znajduje się w pierwszej linijce żądania (\emph{Request-Line}), ale jest duplikowana ponieważ może zostać zmieniona przez serwery pośredniczące.
\item[qop] \hfill \\
Wartość pola jest wybierana na podstawie możliwości oferowanych przez serwer w tym samym polu. Tym razem jednak odsyłana jest pojedyncza wartość, na którą ostatecznie zdecydowała się strona kliencka. Pole jest opcjonalne, ale powinno zostać załączone do żądania jeśli serwer również zwrócił je w odpowiedzi.
\item[nc] \hfill \\
Liczba żądań (łącznie z tym), które zostały dotychczas wysłane z załączoną wartością \emph{nonce} (\emph{nonce count}). Umożliwia to sprawdzenie powtórzeń żądań poprzez trzymanie ich własnego licznika po stronie serwera i porównywanie go z tą wartością.
\item[cnonce] \hfill \\
Wartość ustalana przez stronę kliencką, która również może być wykorzystywana do obliczenia finalnego skrótu. Ma to zapobiec atakom typu \emph{Man In The Middle}, który mógłby mieć miejsce jeśli osoba przechwytująca transmisję miała by pełną kontrolę nad sposobem tworzenia skrótów. Atakujący mógłby preparować wartość \emph{nonce} w taki sposób, aby za każdym razem była taka sama. Dzięki temu będzie można zebrać duży zbiór skrótów od użytkowników gdzie niewiadoma jest zawsze tylko jedna - ich hasła. Wykorzystując ten fakt atakujący może przygotować tablice tęczowe ze skrótami zbudowanymi na spreparowanej wartości \emph{nonce}, co znacznie ułatwi zadanie znalezienia hasła użytkownika. Dodanie dodatkowej niewiadomej, która tym razem pochodzi od użytkownika zabezpiecza przed opisaną sytuacją, znacznie zwiększając nakład obliczeń potrzebny do odgadnięcia wielu haseł z bazy użytkowników atakowanej usługi.
\item[response] \hfill \\
Finalny skrót, będący dowodem autentyczności użytkownika. W zależności od wybranego \emph{qop} oraz algorytmu może zawierać w sobie pola \emph{nonce}, \emph{nc}, \emph{cnonce}, \emph{qop}, \emph{username}, \emph{realm} oraz hasło użytkownika. Zawarcie tych pól w ciągu znaków poddanemu operacji funkcji skrótu uniemożliwia prostą podmianę tych wartości w ich oryginalnych polach przez atakującego.
\item[opaque] \hfill \\
Ciąg znaków zwrócony przez serwer wraz z odpowiedzią \emph{401 Unauthorized}.
\end{description}

Serwer otrzymując ponowne żądanie, tym razem zawierające dane uwierzytelniające próbuje samodzielnie utworzyć skrót korzystając z tych samych algorytmów i zasad, na jakich powstawała wartość przekazywana w polu \emph{response}. Do obliczeń wykorzystuje się pola przesłane z powrotem od klienta, oraz jego hasło odczytane z zewnętrznego źródła (np. bazy danych), więc nie jest wymagane trzymanie stanu tego procesu po stronie serwerowej.

Ponieważ większość informacji jest pozyskiwanych od klienta konieczne jest zabezpieczenie się przed ewentualną podmianą tych wartości, zamieszczając je również w skrócie. W przeciwnym wypadku atakujący mógłby podsłuchać wymianę komunikatów między prawdziwym użytkownikiem, a serwerem oraz wyciągnąć z niego skrót znajdujący się w polu \emph{response}, a następnie podmieniając inne pola komponować własne zapytania. Zmieniając wartość URI żądania mógłby uzyskiwać dostęp do innych zasobów należących do oryginalnego właściciela przechwyconej sesji. Wynik porównania przesłanego i uzyskanego wyniku jest ostatecznym dowodem autentyczności użytkownika.

Należy podkreślić, że schemat \emph{Digest Access Authentication} utajnia jedynie przesyłane hasło użytkownika. Komunikacja nie jest szyfrowana, więc zawsze istnieje ryzyko przechwycenia pakietów oraz przeglądanie zawartości odpowiedzi HTTP zawierającej treść, która ma zostać wyświetlona uwierzytelnionemu użytkownikowi. W razie chęci zabezpieczenia się przed tym, należy skorzystać z szyfrowanego protokołu \emph{HTTPS}.

Niestety podobnie jak jego poprzednik, \emph{Digest Access Authentication} nie pozwala na obsłużenie akcji wylogowania.

\paragraph{Form-based authentication}

Ostatnim omawianym spośród najpopularniejszych schematów uwierzytelniania jest \emph{Form-based authentication}. Protokół \emph{HTTP} w tym wypadku nie bierze bezpośredniego udziału w uwierzytelnianiu użytkownika. Dane autoryzacji nie są przesyłane za pomocą nagłówków, a w treści jego żądania. Z tego wynika, że samodzielnie należy obsłużyć całość procesu.

Kolejnym założeniem jest to, że całość danych przesyłanych jest w czystej postaci. Hasła nie są przetwarzane przez funkcje skrótu na etapie komunikacji, a więc konieczne jest skorzystanie z innego sposobu zabezpieczenia tych danych przed dostępem osób trzecich. Najczęściej oczywiście wykorzystuje się w tym celu protokół \emph{HTTPS}.

Przez zastosowanie szyfrowania komunikacji mamy zapewnioną ochronę nie tylko wrażliwych danych klienta, to znaczy jego prywatnego hasła, ale również innych treści takich jak dane pacjenta, które byłyby przesyłane np. podczas edycji, lub pobieraniu listy pacjentów. Wśród tych danych znajdują się zwykle numery PESEL, adresy e-mail, czy telefon kontaktowy i niedopuszczalne jest umożliwienie dostępu do nich osobom niepowołanym.

Ze względu na to, że metoda \emph{Form-based authentication} nie korzysta z żadnych standardów, przeglądarka nie ma możliwości automatycznie obsłużyć procesu logowania, wobec czego konieczna jest samodzielna implementacja widoku dla tego procesu. Zwykle używa się w tym celu formularzy \emph{<FORM>} języka \emph{HTML}, których zawartość przesyłana jest do serwera metodą \emph{POST} protokołu \emph{HTTP}. W tym wypadku konieczność utworzenia własnego widoku logowania nie jest przeszkodą, ponieważ warto zapewnić spójny interfejs graficzny, z którym użytkownik powinien mieć styczność już na etapie logowania. W przypadku \emph{Basic Access Authentication} oraz \emph{Digest Access Authentication} użytkownikowi zaprezentowane zostanie zaimplementowane w przeglądarce okno dialogowe na tle pustej strony. Przejmując kontrolę nad tym procesem, już na etapie pobierania danych mamy możliwość wyświetlić logo i nazwę produktu oraz obsłużyć błędy logowania wyświetlając przydatne informacje.

W implementacji obsługi logowania metodą \emph{Form-based authentication}, podobnie jak w innych omawianych schematach należy zadbać o to, aby chronione były nie tylko zasoby odpowiadające wyświetlanym treściom (tzn. adresy URL stron i podstron, po których porusza się użytkownik), ale również cała komunikacja mająca miejsce w tle, na przykład wywołania metod \emph{WebService'u} przy pomocy zapytań \emph{AJAX}. Odpowiedzialność tą najlepiej jest przerzucić na instancje znajdujące się na wyższym poziomie abstrakcji, tak jak w wypadku \emph{Basic Access Authentication} oraz \emph{Digest Access Authentication} mógł zajmować się tym serwer WWW lub kontener aplikacji, poprzez zdefiniowanie chronionych adresów URL w pliku konfiguracyjnym. Pozwoli to na uniknięcie konieczności pamiętania o ręcznym wywołaniu procesu sprawdzenia czy użytkownik został uwierzytelniony dla każdej operacji z osobna, przed zwróceniem potencjalnie wrażliwych danych. O tym jak tego dokonać, przeczytać można w podrozdziale \ref{sec:ochronaWybranychZasobow}.

Scenariusz użytkowania usługi zaczyna się operacją logowania niezależnie od tego czy użytkownik wprowadza URL prowadzący bezpośrednio do formularza pozwalającego na uwierzytelnienie się, czy próbuje wejść w zasób chroniony. Należy przy tym podkreślić, że ekran logowania nie jest z oczywistych względów w żaden sposób chroniony - musi być dostępny dla każdego użytkownika chcącego zalogować się w usłudze. W przypadku gdy niezalogowany użytkownik próbuje dostać się do chronionego zasobu, zostaje on automatycznie przekierowany do ekranu logowania. W przeciwieństwie do poprzednio omawianych metod uwierzytelniania, w takim wypadku nie trzeba zwracać komunikatu \emph{401 Unauthorized}, a wystarczy wysłać przekierowanie w postaci odpowiedzi \emph{303 See Other}, który zostanie automatycznie obsłużony przez przeglądarkę kierując użytkownika do podstrony logowania.

Po wypełnieniu danych w formularzu wysyłane jest zapytanie \emph{POST} pod adres operacji uwierzytelniania. Jeśli dane przekazane przez użytkownika są poprawne, rozpoczynana jest sesja, której identyfikatorem od tej pory posługuje się użytkownik jako jedyną wartością potrzebną do udowodnienia swojej tożsamości. Klucz sesji przechowywany jest w plikach \emph{Cookies} po stronie klienta oraz załączany jest do każdego kolejnego żądania.

Sesja ma ograniczony czas trwania, ale może również zostać przedwcześnie przeterminowana poprzez wylogowanie. W przeciwieństwie do metod \emph{Basic Access Authentication} oraz \emph{Digest Access Authentication} mając pełną kontrolę nad procesem uwierzytelniania, można tego łatwo dokonać udostępniając operację unieważniającą klucz sesji wywołującego ją użytkownika.

Więcej o sposobach tworzenia i zarządzania sesją można przeczytać w podrozdziale \ref{sec:sesja}.

\subsection{Wybór metody}

Niezmiernie ważnym aspektem dla wyboru odpowiedniego schematu uwierzytelniania jest uchronienie nie tylko wrażliwych danych użytkownika ale i~pacjenta. \emph{Basic Access Authentication} oraz \emph{Form-based Authentication} nie zapewniają same w sobie ochrony dla żadnego z~nich, podczas gdy \emph{Digest Access Authentication} chroni hasło użytkownika, pozostawiając jednak inne treści w czystej postaci. Konieczne jest zatem, niezależnie od wyboru, wprowadzenie szyfrowania całej komunikacji pomiędzy klientem a~serwerem przy pomocy protokołu \emph{HTTPS}. W takim wypadku korzyść zastosowania \emph{Digest Access Authentication} w miejsce \emph{Basic Access Authentication} jest niewielka, ponieważ dane użytkownika będą bezpieczne niezależnie od wyboru. Prostota \emph{Basic Access Authentication} przemawia na jej korzyść, jednak niesie ze sobą wiele ograniczeń takich jak brak możliwości wylogowania oraz implementacji własnego interfejsu logowania.

\emph{Form-based Authentication} wymaga więcej pracy ze względu na konieczność implementacji obsługi sesji, jednak w aplikacjach tego typu jest najlepszym wyborem dla osiągnięcia pełnej kontroli nad procesem uwierzytelniania.

\subsubsection{Hashowanie}
\label{sec:hashowanie}

W przypadku wycieku bazy zawierającej hasła użytkownika, ich bezpieczeństwo jest zagrożone nie tylko w obrębie usługi, na której przeprowadzono atak, ale też innych serwisów, w których są oni zarejestrowani. Jest to spowodowane bardzo częstą, ale błędną praktyką stosowania tych samych haseł dostępu dla różnych usług przez jedną osobę. Atakujący w przedstawionym przypadku ma zwykle dostęp do haseł oraz innych danych użytkownika, na przykład adresów e-mail, z których może skorzystać, aby odnaleźć inne serwisy, gdzie zarejestrowana dana osoba i dokonać próby włamania. Atak na mało znaczącą dla użytkownika usługę, gdzie bezpieczeństwo może być znacznie obniżone, taką jak forum dyskusyjne czy portal informacyjny, może doprowadzić do przejęcia kontroli nad najistotniejszymi systemami, na przykład pocztą elektroniczną. Niezmiernie ważne jest więc, aby bez względu na wrażliwość przechowywanych danych zapewnić swoim użytkownikom odpowiednie bezpieczeństwo.

Podstawową metodą obrony przed wyciekiem haseł jest przechowywanie ich postaci innej niż dostarczają użytkownicy, do czego służą funkcje skrótu. Ich wynikiem jest skrót, zwany również hashem, który ze względu na jednokierunkowość tej operacji nie pozwala na odzyskanie argumentu wejściowego, jakim jest oryginalne hasło.

Istnieją różne rodzaje funkcji skrótu i nie wszystkie z nich nadają się do bezpiecznego przechowywania haseł. Niezależnie od długości argumentu, przy tej samej konfiguracji wynik będzie miał jednakową długość, a każda najmniejsza zmiana w parametrze wejściowym skutkuje w całkowicie innej przyporządkowanej wartości wynikowej, co obrazuje przykład z wykorzystaniem algorytmu md5.

\begin{lstlisting}
md5("dentaise to aplikacja wspomagająca zarządzanie gabinetem dentystycznym") = 0e100aacf0fe1b20d5cb152bef556626
md5("dentaisf to aplikacja wspomagająca zarządzanie gabinetem dentystycznym") = a572a0958932537c0aa42c5599021491
\end{lstlisting}

Ze względu na ten charakter funkcje skrótu często wykorzystywane są również do sprawdzania integralności danych. W takim wypadku kluczowe jest nie bezpieczeństwo, a szybkość operacji.

W \cite{CSH} wyróżnione zostały następujące ataki mające na celu złamanie skrótu:
\begin{description}
\item[Dictionary] \hfill \\
Atak słownikowy polegający na generowaniu skrótów bazując na zbiorze popularnych haseł stosowanych przez użytkowników, do momentu znalezienia zgodności ze sprawdzanym skrótem.
\item[Brute Force] \hfill \\
Atak polegający na sprawdzaniu wszystkich możliwości, na przykład: aaaaaa, aaaaab, aaaaac...
\item[Lookup Tables] \hfill \\
Metoda umożliwiająca łamanie wielu hashy równolegle poprzez wcześniejsze przygotowanie dużego zbioru skrótów i haseł, na podstawie których zostały wygenerowane. W odróżnieniu od ataku słownikowego metoda ta nie wymaga już obliczania skrótu dla każdego sprawdzanego hasła, co sprawia że jest znacznie szybsza.
\item[Reverse Lookup Tables] \hfill \\
Połączenie podejść \emph{Lookup Table} i ataku słownikowego lub metody \emph{Brute Force}, gdzie najpierw dla wszystkich skrótów znajdujących się w wykradzionej bazie danych przyporządkowuje się użytkowników, którym był przypisany. Następnie oblicza się skrót dla każdego zgadywanego hasła metodą słownikową lub sprawdzając wszystkie kolejne możliwości i sprawdza się którzy użytkownicy mieli uzyskany hash. Metoda ta wykorzystuje fakt, że często wielu użytkowników korzysta z tego samego hasła.
%TODO doczytać http://kestas.kuliukas.com/RainbowTables/
\item[Rainbow Tables] \hfill \\
Usprawnienie metody \emph{Lookup Table}, która ze względu na konieczność przechowywania wszystkich skrótów zajmuje bardzo dużą część przestrzeni dyskowej. Zastosowanie tablic tęczowych pozwala na przechowywanie większej bazy, kosztem czasu potrzebnego na złamanie hasła. Modyfikacja polega na wprowadzeniu funkcji redukującej, która przyporządkowuje skrótom ciągi znaków kwalifikujące się jako hasła. Należy podkreślić, że nie jest to operacja odwracająca operację funkcji skrótu, tzn. wynik redukcji nie jest hasłem na podstawie którego otrzymano skrót, będący wejściem dla tej funkcji. Metoda polega na tworzeniu łańcuchów $plaintext \rightarrow hash \rightarrow plaintext \rightarrow hash \rightarrow \ldots \rightarrow plaintext \rightarrow hash$, gdzie przetrzymywane są jedynie początkowe i końcowe wartości oraz przechodzeniu po nich celem odnalezienia skrótu wejściowego. Szukane hasło jest wartością poprzedzającą. Dokładniejsze wyjaśnienie działania tablic tęczowych można przeczytać w \cite{RT}.
\end{description}

Ataki słownikowe oraz metodą \emph{Brute Force} są najprostszymi sposobami łamania skrótów, ale zarazem bardzo mało wydajnymi czasowo. Wszelkie działania im zapobiegające, jedynie przedłużają czas potrzebny na złamanie skrótu, który jednak jest i tak na tyle długi, że w przypadku kombinacji bezpiecznej funkcji i silnego hasła zagrożenie płynące z zastosowania tych technik jest nikłe.

Kuszące może być podejście obliczania skrótu już po stronie klienta i przesyłanie tej gotowej postaci do sprawdzenia z bazą danych po stronie serwera, dzięki czemu hasło nie jest przekazywane w czystej postaci, co może zostać wykorzystane poprzez podsłuchanie transmisji. Nie jest to zalecane, ponieważ w przypadku wycieku listy skrótów istnieje możliwość włamania się na konto danego użytkownika bez znajomości jego hasła. Z tego względu operacja ta powinna być wykonywana bezwzględnie po stronie serwera, a opisany schemat może być jedynie dodatkowym zabezpieczeniem.

W odróżnieniu od innych zastosowań funkcji skrótów, w bezpieczeństwie szybkość operacji nie jest cechą pożądaną. Wydłużając czas potrzebny do policzenia skrótu, znacznie utrudnia się przeprowadzanie ataku, zwłaszcza przy wykorzystaniu tych dwóch prostych technik. Ze względu na to iż dokonuje się w nich obliczeń na bieżąco dla każdego zgadywanego hasła, potrzeba znacznie więcej czasu na odnalezienie pasującego ciągu znaków, nawet przy minimalnym zmniejszeniu szybkości pojedynczej operacji.

Funkcje skrótu przyporządkowują dane o dowolnej długości do wartości wynikowej o stałym rozmiarze, więc może się zdarzyć, że dwa różne ciągi znaków odpowiadają temu samemu skrótowi. Zdarzenie to nazywa się kolizją i jest niepożądane, kiedy stosuje się je w celach bezpieczeństwa. Funkcje skrótu znacznie minimalizujące tę cechę nazywa się kryptograficznymi funkcjami skrótu. W \cite{CSH} zaleca się stosowanie następujących algorytmów:

\begin{itemize}
\item SHA256
\item SHA512
\item RipeMD
\item WHIRLPOOL
\item SHA3
\item PBKDF2
\item bcrypt
\item scrypt		
\end{itemize}

Według \cite{RIG} największe zagrożenie płynie z zastosowania tanich układów GPU\footnote{Graphics Processing Unit}, FPGA\footnote{Field Programmable Gate Array} lub ASIC\footnote{Application-specific Integrated Circuit}. Wykorzystując ich równoległość atakujący może próbować łamać wiele haseł jednocześnie. Algorytm wymagający dużo zasobów w postaci stosunkowo kosztownej pamięci oraz uniemożliwiający znaczny wzrost szybkości poprzez wykorzystanie wielu rdzeni pozwala na obniżenie ich skuteczności. 

\paragraph{Sól}

Metody \emph{Lookup Table} oraz \emph{Rainbow Table} wykorzystują przygotowane tablice skrótów dla zdefiniowanego zbioru haseł, więc mogą dokonywać wyszukiwania w niezwykle szybki sposób. Zastosowanie silnego algorytmu funkcji skrótu nie będzie w tym wypadku wystarczające, ponieważ w czasie ataku wykona się stosunkowo mało (lub wcale) operacji tego typu.

Najlepszym zabezpieczeniem przed tego typu metodami jest uniemożliwienie przygotowania tablic skrótów dla znanych algorytmów i haseł poprzez wprowadzenie losowego elementu do przetrzymywanych w bazie danych wartości. Aby atak był skuteczny, przygotowane tablice musiałyby uwzględniać ten element, który dla każdego hasła jest inny, co sprawia że przygotowanie tak dużej bazy staje się niemożliwe. Element ten nazywany jest solą.

Sól (\emph{salt}) jest losowym ciągiem znaków o określonej długości, dołączany przed, lub za hasłem (\emph{password}) zanim dokona się operacji skrótu (\emph{hash()}). Dzięki temu podejściu nawet użytkownicy korzystający z tego samego hasła, niezależnie od tego czy zarejestrowani są w tej samej czy innej usłudze, mają przypisany zupełnie inny skrót (\emph{H}). Operację obrazuje poniższy wzór.

$H = hash(salt + password)$

Częstym błędem jest stosowanie tej samej soli dla w obrębie jednej implementowanej usługi. Takie podejście jest mało skutecznie, ponieważ naraża na przygotowanie tablic tęczowych lub \emph{Lookup Tables} specjalnie pod tą wartość. Trzeba również pamiętać o tym, aby wygenerować nową wartość soli za każdym razem, gdy użytkownik zmienia swoje hasło.

Ważną cechą zarówno funkcji skrótu jak i soli jest ich nieprzewidywalność. Należy zatem pamiętać, aby wygenerowane wartości wynikały z użycia kryptograficznie bezpiecznych generatorów liczb pseudolosowych (\emph{CSPRNG}), o których wspomniano również w podrozdziale \ref{sec:identyfikator}.

\paragraph{Przykład}

W implementowanej aplikacji do bezpiecznego przechowywania skrótów haseł zdecydowano się na wykorzystanie algorytmu \emph{PBKDF2}. Poniższy listing przestawia klasę realizującą zadanie przekształcania haseł do skrótów z wykorzystaniem soli.

\begin{lstlisting}[language=Java]
package controllers;

import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;

public class PasswordHashing {
	private static final int SALT_LENGTH = 16; //16 bytes = 128 bits
	private static final int ITERATIONS = 1000;
	private static final int KEYLENGTH = 128;

	public static String hash(String password, String salt) {
		try {
			PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt.getBytes("UTF-8"), ITERATIONS, KEYLENGTH);
			SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1");
			byte hash[] = factory.generateSecret(keySpec).getEncoded();
			return toHex(hash);
		} catch (UnsupportedEncodingException e) {
			throw new RuntimeException(e);
		} catch (InvalidKeySpecException e) {
			throw new RuntimeException(e);
		} catch (NoSuchAlgorithmException e) {
			throw new RuntimeException(e);
		}
	}

	public static String generateSalt() {
		try {
			SecureRandom secureRandom;
			secureRandom = SecureRandom.getInstance("SHA1PRNG");
			byte[] salt = new byte[SALT_LENGTH];
			secureRandom.nextBytes(salt);
			return toHex(salt);
		} catch (NoSuchAlgorithmException e) {
			throw new RuntimeException(e);
		}
	}
	
	private static String toHex(byte[] array) {
		BigInteger bigInteger = new BigInteger(1, array);
		return bigInteger.toString(16);
	}
	
	public static void main(String[] args) {
		String salt = generateSalt();
		String hash = hash("s3cret", salt);
		System.out.println(salt + " " + hash);
	}
	
}
\end{lstlisting}

%TODO: długość klucza

\subsubsection{Sesja}
\label{sec:sesja}

Sesja służy do identyfikacji użytkownika łączącego się z usługą po etapie logowania oraz pozwala na wymuszenie ponownego uwierzytelnienia się po upłynięciu zbyt długiego czasu od ostatniego otrzymanego żądania. Dodatkową zaletą jest wzrost wydajności, poprzez brak konieczności wywoływania kosztownej operacji funkcji skrótu na haśle użytkownika, które w przeciwnym wypadku dołączane by było do każdego żądania.

%TODO zastosowania Cookies?
\paragraph{Cookies}
Po zalogowaniu klient musi automatycznie wysyłać wszystkie żądania wraz z przydzielonym mu identyfikatorem sesji. Ze względu na to iż protokół \emph{HTTP} jest bezstanowy, wykorzystuje się w tym celu \emph{Cookies} (ciasteczka). Jak można przeczytać w \cite{MsC} służą one do przechowywania ogólnego zbioru  informacji dotyczących klienta, takich jak zawartość jego koszyka (w wypadku serwisu realizującego funkcjonalność sklepu internetowego), ustawień dotyczących odwiedzanej witryny, czy jego stanu. Dla przykładu klient może zmienić preferencje widoku strony internetowej, takie jak ustawienie koloru tła. Dane te są początkowo przesyłane w zapytaniu \emph{HTTP} do serwera, na przykład przy pomocy formularza \emph{HTML} i metody \emph{POST}. Po stronie serwera następuje ich analiza i tłumaczenie na polecenia ustawiające je jako ciasteczka na maszynie klienta. W kolejnych zapytaniach ustawienia te są dołączane do wszystkich żądań, dzięki czemu strona wyświetla się zawsze w kolorze wybranym przez użytkownika.

Zgodnie z \cite{RfcC11}, zarządzanie \emph{Cookies} odbywa się przy pomocy dwóch nagłówków protokołu \emph{HTTP}:
\begin{description}
\item[Nagłówek Set-Cookie] \hfill \\
Nagłówek używany do przesyłania ustawień ciasteczek od serwera do klienta w odpowiedzi na jego zapytanie. Przykładowy format widoczny jest poniżej.
\begin{lstlisting}
Set-Cookie: SID=31d4d96e407aad42
\end{lstlisting}
Tak przygotowany nagłówek \emph{Set-Cookie} spowoduje ustawienie ciasteczka o nazwie \emph{SID} (\emph{Session ID}, czyli identyfikator sesji) i wartości \emph{31d4d96e407aad42}. Dodatkowo istnieje możliwość definiowania różnorodnych atrybutów oddzielając je znakiem średnika:
\begin{description}
\item[Path] \hfill \\
Atrybut, który definiuje pulę zasobów, do których może zostać wysłane ciasteczko. Pod uwagę brane są również zasoby zagnieżdżone.
\item[Expires] \hfill \\
Określa maksymalną żywotność ciasteczka. Klient nie ma obowiązku przetrzymywania go, aż do określonej w wartości daty i czasu - ciasteczko może zostać usunięte wcześniej.
\item[Max-Age] \hfill \\
Podobnie jak \emph{Expires} określa maksymalny czas życia ciasteczka, ale definiowany jest jako liczba sekund do czasu wygaśnięcia. Jeśli obydwa atrybuty \emph{Expires} i \emph{Max-Age} występują w jednej odpowiedzi \emph{HTTP}, priorytet ma \emph{Max-Age}.
\item[Domain] \hfill \\
Atrybut służący do określenia zakresu nazw domen, do których wysyłane może być ciasteczko. W przypadku jego pominięcia ciasteczka będą kierowane tylko do serwera, z którego pochodzi odpowiedź.
\item[Secure] \hfill \\
Flaga oznaczająca, że ciasteczko może zostać wysłane tylko przez bezpieczny kanał komunikacji (\emph{HTTPS}). W przypadku transmisji HTTP przy pomocy przeglądarki wspierającej flagę \emph{Secure} zostanie ono pominięte. Więcej na temat konfiguracji tej flagi na różnych serwerach można przeczytać w \cite{SecF}.
\item[HttpOnly] \hfill \\
Flaga, zawężająca dostęp do ciasteczka. W szczególności uniemożliwia jego odczyt z poziomu skryptów znajdujących się po stronie klienta, na przykład JavaScript, co mogłoby doprowadzić do wykradnięcia identyfikatora sesji przy pomocy ataku \emph{Cross-site Scripting}. Jak można przeczytać w \cite{HtOn} funkcjonalność ta jest implementowana po stronie przeglądarek internetowych. Jeżeli zostanie wykryta próba dostępu do ciasteczka oznaczonego flagą \emph{HttpOnly}, zamiast poprawnej wartości zwrócony zostanie pusty ciąg znaków. 
\end{description}
Odpowiedź \emph{HTTP} może konfigurować wiele takich ciasteczek, zawierając je w osobnych nagłówkach, na przykład:
\begin{lstlisting}
Set-Cookie: SID=31d4d96e407aad42; Path=/; Secure; HttpOnly
Set-Cookie: lang=en-US; Path=/; Domain=example.com
\end{lstlisting}
\item[Nagłówek Cookie] \hfill \\
Wszystkie ciasteczka, które mogą zostać wysłane do serwera, z którym komunikuje się klient zostaną zamieszczone w tym nagłówku. Poszczególne pary nazw i wartości oddzielone są średnikami. Żądanie \emph{HTTP} może zawierać tylko jeden nagłówek \emph{Cookie}. Poniższy listing zawiera przykład nagłówka zawierającego dwa ciasteczka, z przykładu zamieszczonego w omówieniu nagłówka \emph{Set-Cookie}: \emph{SID} oraz \emph{lang}.
\begin{lstlisting}
Cookie: SID=31d4d96e407aad42; lang=en-US
\end{lstlisting}
\end{description}

Użycie atrybutu \emph{Expires} nagłówka \emph{Set-Cookie} dodatkowo definiuje sposób w jaki ciasteczka będą przechowywane na maszynie klienta. \cite{MsC} specyfikuje dwa rodzaje \emph{Cookies}:

\begin{description}
\item[Trwałe] \hfill \\
Ten typ ciasteczek zostanie zastosowany jeśli w nagłówku \emph{Set-Cookie} zdefiniowany jest atrybut \emph{Expires}. W takim wypadku ciasteczka przechowywane są w plikach na dysku maszyny klienta, maksymalnie do określonego w nim czasu. Stan jest zachowany pomiędzy różnymi sesjami klienta (czyli po zrestartowaniu przeglądarki internetowej).
\item[Przechowywane w pamięci] \hfill \\
Ciasteczka są przechowywane w pamięci jedynie na czas trwania sesji klienta. Po wyłączeniu przeglądarki znikną.
\end{description}

Warto zauważyć, że w powyższym opisie ``sesja klienta'' nie odnosi się do sesji nawiązywanej pomiędzy klientem a serwerem, która jest głównym tematem tego podrozdziału. W tym szczególnym wypadku jest to sesja użytkowania klienta \emph{HTTP} jakim jest przeglądarka internetowa.

\paragraph{Sesja po stronie klienta lub serwera}

Pierwszym problemem z jakim należy się zmierzyć, jest wybór miejsca przechowywania stanu sesji. 

Jednym z podejść jest trzymanie wszelkich informacji związanych z sesją użytkownika w bazie danych po stronie serwera. Identyfikatorem sesji jest wtedy losowy ciąg znaków o określonej długości, który może posłużyć również jako klucz główny tablicy. Wszelkie inne informacje takie jak czas wygaśnięcia, czy nazwa zalogowanego użytkownika mogą być dodatkowymi kolumnami tablicy. Jedyną wartością jaką przechowuje u siebie klient jest wspomniany identyfikator zapisany w ciasteczkach. Jak sugeruje \cite{ClAu}, zastosowanie tego podejścia umożliwia przeprowadzanie ataku poprzez zgadnięcie identyfikatora, gdzie szansa na powodzenie rośnie wraz ze wzrostem liczby aktualnie zalogowanych użytkowników.

W zamian \cite{ClAu} proponuje rozwiązanie przetrzymywania stanu sesji po stronie klienta. Sesja nie potrzebuje wtedy identyfikatora, gdyż całość informacji przechowywana jest w wartości ciasteczka. Należy przy tym pamiętać, że skoro dane te znajdują się po stronie klienta, mogą zostać przez niego podmienione celem przeprowadzenia ataku. Do dobrych praktyk ochrony przed takim wydarzeniem należy dołączenie skrótu zawartości, sporządzonego przy użyciu tajnego klucza.

Proponowany przykład ma postać przedstawioną poniżej.
\begin{lstlisting}
exp=<EXPIRATION>&data=<DATA>&digest=MAC(exp=<EXPIRATION>&data=<DATA>)
\end{lstlisting}

Poniższy spis objaśnia wartości użyte w ciasteczku.
\begin{description}
\item[<EXPIRATION>] \hfill \\
Wartość parametru \emph{exp}, określającego żywotność sesji, na przykład jako liczba sekund, które upłynęły od 00:00, 1 stycznia 1970 r.
\item[<DATA>] \hfill \\
Wartość parametru \emph{data}, który przechowuje wszelkie dane związane z klientem, charakterystyczne dla implementowanej usługi.
\item[MAC(exp=<EXPIRATION>\&data=<DATA>)] \hfill \\
Wartość parametru \emph{digest}, będącego potwierdzeniem autentyczności danych przesyłanych od klienta. Dane te muszą zostać zabezpieczone przed ewentualną podmianą przez atakującego, więc dołączane są w postaci kodu \emph{MAC}\footnote{Message Authentication Code; Kod uwierzytelniania wiadomości}, który jest wynikiem funkcji skrótu, wykorzystującej tajny klucz, na danych mających być objętymi ochroną przed sfałszowaniem. Podmiana wartości parametrów \emph{exp} oraz \emph{data} zostanie z łatwością wykryta poprzez porównanie załączonego skrótu ze skrótem wyliczonym w momencie otrzymania żądania, na podstawie tychże danych. Ze względu na wykorzystanie tajnego klucza w fazie liczenia skrótu, klient nie jest w stanie sam wygenerować poprawnej jego wartości na podstawie sfałszowanych parametrów.
\end{description}

\cite{SeMa08} wymienia następujące zalety tego podejścia:
\begin{itemize}
\item Łatwiejsze w realizacji równoważenie obciążenia pomiędzy serwerami, oraz wysoka dostępność.
\item Mniejsze zużycie pamięci na serwerze.
\item Szybsze odpowiedzi i mniejszy koszt serwera, jako skutek braku potrzeby dedykowanego systemu równoważenia obciążenia.
\item Mniejsza złożoność wdrożenia.
\end{itemize}

%To wciąż cytat... dodać odnośnik?
W przechowywaniu sesji po stronie klienta istnieją również jednak pewne wady:
\begin{itemize}
\item Jeśli ciasteczko nie jest szyfrowane, stan sesji może zostać podsłuchany.
\item Stan przechowywany w ciasteczku może zostać zmieniony, jeśli nie jest się przed tym odpowiednio zabezpieczonym (na przykład jak w zaprezentowanym powyżej przykładzie z \emph{MAC}).
\item Rozmiar ciasteczek jest ograniczony, co zmniejsza również możliwości przechowywania sesji zawierających duże ilości danych.
\item Konieczne jest przesłanie większej ilości danych reprezentujących stan (w odróżnieniu do tylko jednej wartości - identyfikatora sesji - dla stanu trzymanego po stronie serwera).
\item Istnieje większa podatność na atak Replay.
\item Unieważnianie sesji jest utrudnionym zadaniem, ponieważ serwer nie ma możliwości sprawdzić, które sesje zostały już zakończone.
\end{itemize}

Podejście, w którym przechowuje się stan sesji po stronie klienta może być również bardzo korzystne dla aplikacji, które nie wymagają bazy danych do realizacji pozostałych funkcjonalności. Nie pasuje to jednak do profilu tworzonego systemu, wobec czego utworzenie dodatkowej tabeli dla sesji użytkowników nie jest problematyczne. Nie oczekuje się również, że system kiedykolwiek będzie wymagał równoważenia obciążenia, ze względu na wąskie grono jego użytkowników. Zgadnięcie identyfikatorów przez atakujących można znacznie zminimalizować poprzez zastosowanie wskazówek z podrozdziału \ref{sec:identyfikator}. Ostatecznie jednak przetrzymywanie sesji po stronie serwera wydaje się być bardziej trafionym podejściem dla tworzonego systemu.

Jak sugeruje \cite{ClAu} ciasteczka zawierające identyfikator sesji nie powinny być trwałe\footnote{tzn. nie powinno się deklarować atrybutu \emph{Expires} w nagłówku \emph{Set-Cookie}}, ponieważ zwiększa to ryzyko wykradnięcia poufnych danych. Jeśli dane te przetrzymywane są w pamięci, dostęp do nich jest znacznie bardziej utrudniony. Dodatkowo jeżeli użytkownik loguje się do usługi z publicznego urządzenia, kolejne osoby korzystające z niego będą miały dostęp do konta poprzednika.

Z punktu widzenie bezpieczeństwa najważniejsze jest, aby ciasteczko przechowujące identyfikator sesji spośród dostępnych atrybutów zawierało flagi \emph{Secure} oraz \emph{HttpOnly}.

\paragraph{Identyfikator}
\label{sec:identyfikator}

Użycie identyfikatora sesji pozwala na komunikację bez przesyłania hasła, więc należy zadbać o to, aby był on odpowiednio bezpieczny. Każda osoba znająca (lub zgadująca) poprawny identyfikator może uzyskać dostęp do chronionych zasobów, więc jej poprawne użycie jest równie ważne co obsługa początkowej fazy uwierzytelniania.

Jednym z najważniejszych sposobów zminimalizowania prawdopodobieństwa odgadnięcia identyfikatora sesji jest ustalenie jego odpowiedniej długości. Zarówno \cite{SId} jak i \cite{SeMa08} zalecają minimum 128-bitowy identyfikator.

Kolejnym, niemniej ważnym warunkiem jest korzystanie z kryptograficznie bezpiecznego generatora liczb pseudolosowych (CSPRNG\footnote{Cryptographically Secure Pseudo-Random Number Generator}). Klasa \emph{Random} języka Java nie spełnia tego warunku. Każda kolejna losowana liczba, liczona jest na podstawie poprzedniej, co sprawia, że zastosowany algorytm bazujący na LCF\footnote{Linear Congruential Formula} jest przewidywalny. Jego zaletą jest szybkość, ale nie może być stosowany do generowania losowych wartości, na których opiera się bezpieczeństwo aplikacji. W języku \emph{Java} istnieje kryptograficznie bezpieczna alternatywa pod postacią klasy \emph{SecureRandom}. Źródłem jej entropii są nieprzewidywalne procesy systemowe czy sterowniki urządzeń \cite{RND}. Więcej na temat generatorów liczb pseudolosowych na platformie \emph{Java} można przeczytać w \cite{SRNGiJ}.

Dla lepszego zobrazowania bezpieczeństwa identyfikatora respektującego przedstawione wytyczne, warto przyjrzeć się wzorowi określającemu liczbę sekund potrzebną do zgadnięcia identyfikatora sesji, przedstawionemu w \cite{SId}:

$\frac{2^{B} + 1}{2A \cdot S}$

gdzie \emph{A} jest liczbą prób zgadnięć identyfikatora, które atakujący jest w stanie przeprowadzić w ciągu sekundy, \emph{B} jest liczbą bitów entropii w identyfikatorze, a \emph{S} to liczba identyfikatorów sesji, które są aktualnie akceptowalne do użycia, czyli w poprawnie funkcjonującym systemie jest to liczba aktualnie zalogowanych użytkowników.

Dla przykładu podstawiając pod A wartość $1000$, pod B wartość $64$ (szacuje się że liczba bitów entropii w CSPRNG to połowa \cite{SId}; $128/2=64$), a pod S $2000$ otrzymujemy $4,611686018\cdot10^{12}$ sekund, czyli $146235,604338768$ lat. Warto dodać, że podstawione wartości były znacznie zawyżone. Tak duża ilość zapytań z pewnością zostałaby zablokowana przez firewall, a liczbę użytkowników zalogowanych na raz w przypadku tworzonego systemu szacuje się na maksymalnie kilku.

%TODO wireshark, przykład

\subsection{Reset hasła}

tokeny, mail

\subsection{Ochrona wybranych zasobów}
\label{sec:ochronaWybranychZasobow}

zwykłe podejście czyli chroniony url (trochę o podejściu klasycznym tzn. ochrona url bez wiedzy aplikacji z logowaniem jako osobny niechroniony moduł) vs adnotacje
@Secured, przekierowania, sesja (krótko, więcej w osobnym rozdziale)

\subsection{HTTPS}

używane cały czas, nie tylko przy logowaniu (sessionId jest hasłem!)

\subsection{SQL Injection}

\subsection{XSS}


%----------------------------------------------------------------------------

\chapter{Opis}
\label{cha:opis}

\section{Web}
\subsection{Zakres}
\subsection{Prezentacja}
\section{Mobile}
\subsection{Zakres}
\subsection{Prezentacja}
\section{User Experience}
układ formularzy, komunikaty po akcjach (do zrobienia?), walidacja pól, kalendarz, wyszukiwarka, paginacja, (walidacja PESEL??)
%----------------------------------------------------------------------------

\chapter{Konfiguracja i uruchomienie}
\label{cha:konfiguracja_i_uruchomienie}
a może jako dodatek zamiast rozdziału?

\subsection{Baza danych}
\subsection{Play Framework}
%pamiętaj o https
\subsubsection{Instalacja}
\subsubsection{Plik application.conf}
baseUrl, smtp.host, database itp...
\subsection{Android SDK}
\subsection{Zależności}
\subsubsection{Sbt}
\subsubsection{Gradle}
\subsection{Uruchomienie}

% itd.
% \appendix
% \include{dodatekA}
% \include{dodatekB}
% itd.

\label{cha:bibliografia}

\bibliographystyle{alpha}
\bibliography{bibliografia}

\end{document}
